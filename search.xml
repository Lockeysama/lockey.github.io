<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 开源仓库系统 Harbor 搭建与使用</title>
      <link href="/2020/03/12/Linux/Docker%E5%BC%80%E6%BA%90%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9FHarbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/12/Linux/Docker%E5%BC%80%E6%BA%90%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9FHarbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="未完"><a class="header-anchor" href="#未完"></a>未完</h2><section class="reference"><p>v2使用https，登录不上，docker daemon 增加 insecure registries</p><p>“insecure-registries” : [“<a href="http://harbor-register.entertech.cn" target="_blank" rel="noopener">harbor-register.entertech.cn</a>”]</p><p>systemctl daemon-reload</p><p>systemctl restart docker</p></section>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04 KVM 安装使用（GUI）</title>
      <link href="/2020/03/12/Linux/Ubuntu18.04--KVM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/12/Linux/Ubuntu18.04--KVM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a class="header-anchor" href="#准备"></a>准备</h2><section class="reference"></section><h5 id="检查硬件虚拟化支持"><a class="header-anchor" href="#检查硬件虚拟化支持"></a>检查硬件虚拟化支持</h5><section class="reference"><p>$<code>egrep -c '(vmx|svm)' /proc/cpuinfo</code><br>输出大于0即可</p></section><h5 id="检查硬件加速-kvm-支持"><a class="header-anchor" href="#检查硬件加速-kvm-支持"></a>检查硬件加速 KVM 支持</h5><section class="reference"><p>$<code>apt install cpu-checker</code><br>$<code>kvm-ok</code><br>输出：<code>KVM acceleration can be used</code>即可</p></section><h5 id="桥接模式-可选"><a class="header-anchor" href="#桥接模式-可选"></a>桥接模式(可选)</h5><section class="reference"><p>设置宿主机桥接网络，Netplan 模式下的 NetworkManager 管理方式使用 $<code>nm-connection-editor</code>进行管理</p></section><h2 id="安装-kvm"><a class="header-anchor" href="#安装-kvm"></a>安装 KVM</h2><section class="reference"><p>$<code>apt install -y qemu qemu-kvm libvirt-bin bridge-utils virt-manager</code></p></section><h5 id="启动和开机启动-libvirt-服务"><a class="header-anchor" href="#启动和开机启动-libvirt-服务"></a>启动和开机启动 libvirt 服务</h5><section class="reference"><p>$<code>systemctl start libvirtd</code><br>$<code>systemctl enable libvirtd</code></p></section><h2 id="使用-kvm"><a class="header-anchor" href="#使用-kvm"></a>使用 KVM</h2><section class="reference"><p>可以使用 $<code>virt-manager</code> GUI 界面管理<br>安装完系统，设置设置虚拟机 NIC 信息（在虚拟机信息面板）为：指定共享设备，输入宿主机桥接网络名(如：br0)，选择 virtio 即可</p><div class="warning"><p>博主桥接网络设置静态 IP 没成功，实在不行可以使用 DHCP 自动分发！</p></div></section><h5 id="kvm-常用命令"><a class="header-anchor" href="#kvm-常用命令"></a>KVM 常用命令</h5><section class="reference"><p>命令 | 功能 | 备注<br>—:---:—<br>virsh list | 查看运行虚拟机 | 查看所有可以加<code>--all</code>参数</p></section><h3 id="未完-待续"><a class="header-anchor" href="#未完-待续"></a>未完…待续…</h3><section class="reference"></section>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Ubuntu18.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础随笔</title>
      <link href="/2020/03/12/Linux/Linux%E5%9F%BA%E7%A1%80%E9%9A%8F%E7%AC%94/"/>
      <url>/2020/03/12/Linux/Linux%E5%9F%BA%E7%A1%80%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-与-发行版"><a class="header-anchor" href="#linux-与-发行版"></a>Linux 与 发行版</h2><section class="reference"></section><h2 id="发行版"><a class="header-anchor" href="#发行版"></a>发行版</h2><section class="reference"></section><h3 id="ubuntu"><a class="header-anchor" href="#ubuntu"></a>Ubuntu</h3><section class="reference"></section><h4 id="镜像版本与后缀"><a class="header-anchor" href="#镜像版本与后缀"></a>镜像版本与后缀</h4><section class="reference"></section><h5 id="desktop"><a class="header-anchor" href="#desktop"></a>Desktop</h5><section class="reference"><p>桌面版：通常指带操作界面的版本（类似 Win 系统和 Mac 系统）</p></section><h5 id="live-server"><a class="header-anchor" href="#live-server"></a>Live-Server</h5><section class="reference"><p>服务器版：通常不包含界面，操作靠命令终端，安装时可以选择性安装额外插件或最小化安装。大部分服务器会选择这种类型的镜像。</p></section>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用K8S搭建（Ubuntu18.04）</title>
      <link href="/2020/03/11/DevOps/%E9%AB%98%E5%8F%AF%E7%94%A8K8S%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/11/DevOps/%E9%AB%98%E5%8F%AF%E7%94%A8K8S%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<div class="warning"><p>本文资料整理自网络，对其中过时部分进行修正！<br>运行环境为：KVM 虚拟机（先根据下文第一部分制作基础镜像，再用基础镜像克隆为各个 master、worker 节点，可以节省时间）<br>适用版本为：<br>操作系统：Ubuntu18.04<br>Kubeadm：GitVersion:&quot;v1.17.3&quot;<br>K8S组件版本如下：<br>kube-apiserver:v1.17.4<br>kube-controller-manager:v1.17.4<br>kube-scheduler:v1.17.4<br>kube-proxy:v1.17.4<br>pause:3.1<br>etcd:3.4.3-0<br>coredns:1.6.5</p></div><h2 id="第一部分-基础镜像准备"><a class="header-anchor" href="#第一部分-基础镜像准备"></a>第一部分----基础镜像准备</h2><section class="reference"></section><h4 id="harbor-安装"><a class="header-anchor" href="#harbor-安装"></a>Harbor 安装</h4><section class="reference"><p>详见</p></section><h4 id="确保节点之中不可以有重复的主机名-mac-地址或-product-uuid"><a class="header-anchor" href="#确保节点之中不可以有重复的主机名-mac-地址或-product-uuid"></a>确保节点之中不可以有重复的主机名、MAC 地址或 product_uuid</h4><section class="reference"></section><h5 id="hostname-修改"><a class="header-anchor" href="#hostname-修改"></a>hostname 修改</h5><section class="reference"><ul><li>Ubuntu：<code>hostnamectl set-hostname xxx</code></li></ul></section><h5 id="查看-product-uuid"><a class="header-anchor" href="#查看-product-uuid"></a>查看 product_uuid</h5><section class="reference"><p><code>sudo cat /sys/class/dmi/id/product_uuid</code></p></section><h4 id="关闭防火墙-生产环境不建议关闭"><a class="header-anchor" href="#关闭防火墙-生产环境不建议关闭"></a>关闭防火墙（生产环境不建议关闭）</h4><section class="sample"><pre><code>systemctl stop ufwsystemctl disable ufw</code></pre></section><section class="reference"><div class="warning"><p>生产环境，建议启用防火墙，并开启 etcd、apiserver等多个端口</p></div></section><h4 id="关闭-swap"><a class="header-anchor" href="#关闭-swap"></a>关闭 swap</h4><section class="reference"><p>查看 swap：$<code>cat /proc/swaps</code><br>注释 swap 设置：$<code>vim /etc/fstab</code><br>关闭 swap：$<code>swapoff -a</code></p></section><h4 id="禁用-grub-ipv6"><a class="header-anchor" href="#禁用-grub-ipv6"></a>禁用 GRUB ipv6</h4><section class="sample"><p>编辑：$<code>vim /etc/default/grub</code><br>修改：</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;GRUB_CMDLINE_LINUX=&quot;&quot;</code></pre></section><section class="reference"><p>↓</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;ipv6.disable=1&quot;GRUB_CMDLINE_LINUX=&quot;ipv6.disable=1&quot;</code></pre><p>更新：$<code>update-grub</code></p></section><h4 id="设置对应时区-如上海"><a class="header-anchor" href="#设置对应时区-如上海"></a>设置对应时区（如上海）</h4><section class="reference"><p>执行：$<code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></section><h4 id="设置-dns"><a class="header-anchor" href="#设置-dns"></a>设置 DNS</h4><section class="sample"><p>编辑：$<code>vim /etc/systemd/resolved.conf</code><br>修改：</p><pre><code># 地址来自阿里 DNSDNS=223.5.5.5 223.6.6.6 </code></pre></section><section class="reference"></section><h4 id="升级操作系统内核"><a class="header-anchor" href="#升级操作系统内核"></a>升级操作系统内核</h4><section class="reference"><p>参考自<a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/#%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">青木のJava小屋</a></p><p>查看本机内核：$<code>uname -a</code></p><div class="info"><p>可以根据实际情况<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">选择版本</a></p></div><p>执行：$<code>dpkg -i xxx.deb</code>升级内核（可使用通配符）</p><p>清理旧内核：$<code>dpkg --list | grep linux | awk '{print $2}' | grep 旧内核版本 | xargs apt purge -y</code></p><div class="warning"><p>内核操作风险较大，请一步步确认没问题再执行！</p></div></section><h4 id="启用-ipvs-内核模块"><a class="header-anchor" href="#启用-ipvs-内核模块"></a>启用 IPVS 内核模块</h4><section class="sample"><p>执行：</p><pre><code>echo &gt; /etc/modules-load.d/ipvs.confmodule=(ip_vs        ip_vs_rr        ip_vs_wrr        ip_vs_sh        ip_vs_lc        br_netfilter        nf_conntrack)for kernel_module in ${module[@]};do    /sbin/modinfo -F filename $kernel_module |&amp; grep -qv ERROR &amp;&amp; echo $kernel_module &gt;&gt; /etc/modules-load.d/ipvs.conf || :done</code></pre></section><section class="reference"><p>查看：$<code>lsmod | grep ip_vs</code><br>输出如下信息为成功 ↓</p><pre><code>ip_vs_sh               16384  0ip_vs_wrr              16384  0ip_vs_rr               16384  0ip_vs                 147456  6 ip_vs_rr,ip_vs_sh,ip_vs_wrrnf_conntrack          143360  6 xt_conntrack,nf_nat,ipt_MASQUERADE,nf_nat_ipv4,nf_conntrack_netlink,ip_vslibcrc32c              16384  5 nf_conntrack,nf_nat,btrfs,raid456,ip_vs</code></pre></section><h4 id="内核参数调整"><a class="header-anchor" href="#内核参数调整"></a>内核参数调整</h4><section class="sample"><pre><code>cat &gt; /etc/sysctl.conf &lt;&lt; EOF# https://github.com/moby/moby/issues/31208 # ipvsadm -l --timout# 修复ipvs模式下长连接timeout问题 小于900即可net.ipv4.tcp_keepalive_time = 800net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.bridge.bridge-nf-call-arptables = 1vm.swappiness = 0vm.max_map_count=262144EOF</code></pre></section><section class="reference"></section><h4 id="确保-iptables-工具不使用-nftables-后端"><a class="header-anchor" href="#确保-iptables-工具不使用-nftables-后端"></a>确保 iptables 工具不使用 nftables 后端</h4><section class="reference"></section><h5 id="切换旧版-ubuntu"><a class="header-anchor" href="#切换旧版-ubuntu"></a>切换旧版（Ubuntu）</h5><section class="sample"><pre><code>update-alternatives --set iptables /usr/sbin/iptables-legacyupdate-alternatives --set ip6tables /usr/sbin/ip6tables-legacyupdate-alternatives --set arptables /usr/sbin/arptables-legacyupdate-alternatives --set ebtables /usr/sbin/ebtables-legacy</code></pre></section><section class="reference"></section><h4 id="docker-ce-安装"><a class="header-anchor" href="#docker-ce-安装"></a>docker-ce 安装</h4><section class="reference"><p>安装依赖系统工具：$<code>apt install -y apt-transport-https ca-certificates curl software-properties-common</code><br>安装GPG证书：$<code>curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code><br>写入源：$<code>add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code><br>执行：$<code>apt update</code><br>安装 docker-ce：$<code>apt install -y docker-ce</code>（另可指定版本号安装指定版本）<br>设置镜像加速，可以选择阿里云镜像加速服务，详见阿里云镜像加速页面文档</p></section><h4 id="docker-compose-安装"><a class="header-anchor" href="#docker-compose-安装"></a>docker-compose 安装</h4><section class="sample"><p>执行：</p><pre><code>curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre></section><section class="reference"></section><h4 id="kubeadm-套件安装-国内"><a class="header-anchor" href="#kubeadm-套件安装-国内"></a>Kubeadm 套件安装（国内）</h4><section class="reference"><p>新增源文件：$<code>vim /etc/apt/sources.list.d/kubernetes.list</code><br>写入源：$<code>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</code><br>执行：$<code>apt update</code> 得到错误信息的 key 的末尾8位<br>执行：$<code>gpg --keyserver keyserver.ubuntu.com --recv-keys 【8位key】</code><br>执行：$<code>gpg --export --armor 【8位key】 | sudo apt-key add -</code><br>再次执行：$<code>apt update</code><br>安装 Kubeadm 套件：$<code>apt install -y kubelet kubeadm kubectl</code></p></section><h2 id="第二部分-高可用集群搭建"><a class="header-anchor" href="#第二部分-高可用集群搭建"></a>第二部分----高可用集群搭建</h2><section class="reference"><div class="info"><p>本文高可用模式为：ETCD 高可用 + API-Server 高可用<br>ETCD：由于 ETCD 使用 Raft 算法，所以节点一般为奇数个，本文使用3个节点<br>API-Server：本文使用3个节点</p></div></section><h4 id="nginx-本地代理"><a class="header-anchor" href="#nginx-本地代理"></a>Nginx 本地代理</h4><section class="reference"><p>用于访问 master 节点，并在其中某些 master 节点不可用时，自动访问可用节点。<br>可以部署在每一台 K8S 节点上部署，也可另外部署外部 Nginx 负载均衡节点，本文在每台 K8S 节点上均有部署</p></section><h5 id="配置-master-节点-hosts"><a class="header-anchor" href="#配置-master-节点-hosts"></a>配置 master 节点 hosts</h5><section class="sample"><pre><code>cat &gt;&gt; /etc/hosts &lt;&lt; EOF127.0.0.1 server.k8s.local10.0.0.65 server1.k8s.local10.0.0.66 server2.k8s.local10.0.0.67 server3.k8s.localEOF</code></pre></section><section class="reference"><div class="warning"><p>IP 请跟请根据实际情况替换</p></div></section><h5 id="编写-nginx-配置文件"><a class="header-anchor" href="#编写-nginx-配置文件"></a>编写 Nginx 配置文件</h5><section class="sample"><pre><code>mkdir -p /etc/nginxcat &gt; /etc/nginx/nginx.conf &lt;&lt; EOFworker_processes auto;user root;events {    worker_connections  20240;    use epoll;}error_log /var/log/nginx_error.log info;stream {    upstream kube-servers {        hash $remote_addr consistent;        server server1.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;        server server2.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;        server server3.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;    }    server {        listen 8443 reuseport;        proxy_connect_timeout 3s;        # 加大timeout        proxy_timeout 3000s;        proxy_pass kube-servers;    }}EOF</code></pre></section><section class="reference"></section><h5 id="启动-nginx"><a class="header-anchor" href="#启动-nginx"></a>启动 Nginx</h5><section class="sample"><pre><code>docker run --restart=always \-v /etc/apt/sources.list:/etc/apt/sources.list \-v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf \--name kps \--net host \-it \-d \nginx</code></pre></section><section class="reference"></section><h4 id="高可用外部-etcd-集群搭建"><a class="header-anchor" href="#高可用外部-etcd-集群搭建"></a>高可用外部 ETCD 集群搭建</h4><section class="sample"><div class="info"><p>由于 etcd 不需要对外开放，所以本文不使用 tls</p></div><div class="warning"><p>启动参数<a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">注意事项</a>：<br>–auto-compaction-retention<br>由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入;所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次;推荐一小时压缩一次数据这样可以极大的保证集群稳定，减少内存和磁盘占用</p><p>–max-request-bytes<br>etcd Raft消息最大字节数，ETCD默认该值为1.5M; 但是很多业务场景发现同步数据的时候1.5M完全没法满足要求，所以提前确定初始值很重要;由于1.5M导致我们线上的业务无法写入元数据的问题，我们紧急升级之后把该值修改为默认32M，但是官方推荐的是10M，大家可以根据业务情况自己调整</p><p>–quota-backend-bytes<br>ETCD db数据大小，默认是2G，当数据达到2G的时候就不允许写入，必须对历史数据进行压缩才能继续写入;参加1里面说的，我们启动的时候就应该提前确定大小，官方推荐是8G，这里我们也使用8G的配置</p></div><p>在 etcd 集群个节点主机上运行如下命令（注意修改中括号内对应的信息）：</p><pre><code>mkdir -p /var/etcddocker rm [name] -frm -rf /var/etcd/*docker run --restart=always --net host -it --name [name] -d \-v /var/etcd:/var/etcd \-v /etc/localtime:/etc/localtime \[仓库名]/etcd:[版本号] \etcd --name [etcd name] \--auto-compaction-retention &quot;1h&quot; --max-request-bytes &quot;33554432&quot; --quota-backend-bytes &quot;8589934592&quot; \--data-dir=/var/etcd/etcd-data \--listen-client-urls http://0.0.0.0:2379 \--listen-peer-urls http://0.0.0.0:2380 \--initial-advertise-peer-urls http://[本节点域名或IP]:2380 \--advertise-client-urls http://[本节点域名或IP]:2379,http://[本节点域名或IP]:2380 \-initial-cluster-token etcd-cluster \-initial-cluster &quot;[本机 etcd name]=http://[本节点域名或IP]:2380,[其他etcd name1]=http://[其他节点域名或IP]:2380,[其他etcd name2]=http://[其他节点域名或IP]:2380&quot; \-initial-cluster-state new</code></pre></section><section class="reference"></section><h5 id="测试-etcd-集群"><a class="header-anchor" href="#测试-etcd-集群"></a>测试 etcd 集群</h5><section class="sample"><p>进入正在运行的 etcd 容器：$<code>docker exec -it [name] sh</code><br>查看集群状态：$<code>etcdctl --write-out=table --endpoints=&quot;http://[节点域名或IP]:2379,http://[节点域名或IP]:2379,http://[节点域名或IP]:2379&quot; endpoint status</code><br>查看集群健康：$<code>etcdctl --write-out=table --endpoints=&quot;http://[节点域名或IP]:2379,http://[节点域名或IP]:2379,http://[节点域名或IP]:2379&quot; endpoint health</code></p><p>测试集群可用性：</p><pre><code># 任意节点存入数据etcdctl put /test/key &quot;123&quot;# 任意节点取出数据，取出正常，集群可用etcdctl get /test/key</code></pre></section><section class="reference"></section><h4 id="api-server-master-高可用"><a class="header-anchor" href="#api-server-master-高可用"></a>API-Server（Master） 高可用</h4><section class="reference"></section><h5 id="配置自定义-kubeadm-config-yaml"><a class="header-anchor" href="#配置自定义-kubeadm-config-yaml"></a>配置自定义 kubeadm-config.yaml</h5><section class="sample"><div class="warning"><p>注意修改对应的版本号，仓库路径等</p></div><pre><code>apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.17.0imageRepository: [仓库路径]apiServer:  extraArgs:    storage-backend: etcd3  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtime  certSANs:    - &quot;prod-server.k8s.local&quot;    - &quot;server1.k8s.local&quot;    - &quot;server2.k8s.local&quot;    - &quot;server3.k8s.local&quot;    - &quot;127.0.0.1&quot;    - &quot;10.0.0.65&quot;    - &quot;10.0.0.66&quot;    - &quot;10.0.0.67&quot;    - &quot;kubernetes&quot;    - &quot;kubernetes.default&quot;    - &quot;kubernetes.default.svc&quot;    - &quot;kubernetes.default.svc.cluster&quot;    - &quot;kubernetes.default.svc.cluster.local&quot;controllerManager:  extraArgs:    experimental-cluster-signing-duration: 867000h  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtimescheduler:  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtimenetworking:  # pod 网段  podSubnet: 172.224.0.0/12  # SVC 网络  serviceSubnet: 10.96.0.0/12controlPlaneEndpoint: server.k8s.local:8443etcd:  external:    endpoints:      - http://server1.k8s.local:2379      - http://server2.k8s.local:2379      - http://server3.k8s.local:2379---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationmode: ipvsipvs:  scheduler: lc  minSyncPeriod: 5s  syncPeriod: 15s</code></pre></section><section class="reference"></section><h5 id="初始化-master"><a class="header-anchor" href="#初始化-master"></a>初始化 Master</h5><section class="reference"><p>执行：$<code>kubeadm init --config=kubeadm-config.yaml --upload-certs</code></p><div class="info"><p>–config=kubeadm-config.yaml 为上一步骤编写的文件<br>–upload-certs 参数将证书上传到 etcd 中，后续不需要手动分发</p></div><p>初始化结束，控制台输出：<br>Your Kubernetes control-plane has initialized successfully!</p><p>To start using your cluster, you need to run the following as a regular user:<br><strong><em>复制并执行下列命令：可以以普通用户操作集群</em></strong><br><font color=red>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config</font></p><p>You should now deploy a pod network to the cluster.<br>Run “kubectl apply -f [podnetwork].yaml” with one of the options listed at:<br><a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p><p>You can now join any number of the control-plane node running the following command on each as root:<br><strong><em>复制并执行下列命令：其余 master 可以加入到到该集群</em></strong><br><font color=green>kubeadm join server.k8s.local:8443 --token uue99t.w9cenfznjoo2e1u6 <br>–discovery-token-ca-cert-hash sha256:afd406ce180ce4c9271c0e7b4c3381df72cd75e766f934fd439d101ae1022a43 <br>–control-plane --certificate-key 1621bb7101d2fa4050779aaa753e89d49ee7db57129b6b4986c82b45fb4dcbe5</font    ></p><p>Please note that the certificate-key gives access to cluster sensitive data, keep it secret!<br>As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use<br>&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</p><p>Then you can join any number of worker nodes by running the following on each as root:<br><strong><em>复制并执行下列命令：worker 可以加入到到该集群</em></strong><br><font color=blue>kubeadm join server.k8s.local:8443 --token uue99t.w9cenfznjoo2e1u6 <br>–discovery-token-ca-cert-hash sha256:afd406ce180ce4c9271c0e7b4c3381df72cd75e766f934fd439d101ae1022a43<font></p><div class="warning"><p>以上命令中出现的 hash、key 需要跟使用者安装后出现的一致，不可直接复制使用！<br>Token 失效可以使用命令重新生成 ↓<br>创建一个新的token：<br>kubeadm token create<br>查看token列表：<br>kubeadm token list<br>获取ca证书sha256编码hash值：<br>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'<br>最终生成的cmd：<br>kubeadm join server.k8s.local:8443 --token ${TOKEN} --discovery-token-ca-cert-hash sha256:${CaSHA256}</p></div></section><h5 id="master-测试"><a class="header-anchor" href="#master-测试"></a>master 测试</h5><section class="reference"><p>执行：$<code>kubectl get node</code> 可以查看集群是否加入成功（可以显示加入集群内的所有节点）<br>执行：$<code>kubectl get pod -A</code> 可以查看所有集群内正在运行的pod（检查 apiserver、controller-manager、proxy、scheduler 是否是 running 状态，coredns 目前为 pending 状态）</p></section><h4 id="结束"><a class="header-anchor" href="#结束"></a>结束</h4><section class="reference"><p>至此，高可用 K8S 安装成功。</p><p><strong><em>参考链接</em></strong><br><a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/" target="_blank" rel="noopener">在阿里云的VPC部署高可用kubernetes</a></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 编排 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S</title>
      <link href="/2019/12/31/DevOps/K8S/"/>
      <url>/2019/12/31/DevOps/K8S/</url>
      
        <content type="html"><![CDATA[<h2 id="部署的演化历史"><a class="header-anchor" href="#部署的演化历史"></a>部署的演化历史</h2><section class="reference"><ul><li>传统部署<ul><li>资源分配问题</li></ul></li><li>虚拟化部署<ul><li>量级较重</li></ul></li><li>容器化部署<ul><li>敏捷应用程序的创建和部署</li><li>持续开发、集成和部署方便</li><li>开发运维分离</li><li>可观察性丰富</li><li>跨开发、测试和生产环境一致</li><li>云和操作系统分发的可移植性强</li><li>以应用程序为中心管理</li><li>适合松散耦合、分布式、弹性、解放的微服务</li><li>资源隔离</li><li>资源利用率高</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="部署演进历史.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="容器部署时代面临的问题"><a class="header-anchor" href="#容器部署时代面临的问题"></a>容器部署时代面临的问题</h2><section class="reference"></section><h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5><section class="reference"><ul><li>服务集群越来越大</li><li>传统的集群容器部署方式较繁琐</li><li>工作量日益加大</li><li>容易出错</li></ul></section><h5 id="解决方向"><a class="header-anchor" href="#解决方向"></a>解决方向</h5><section class="reference"><p>需要一个强大的容器管理、编排系统</p></section><h5 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h5><section class="reference"><p>kubernetes[K8S]</p></section><h2 id="k8s是什么？"><a class="header-anchor" href="#k8s是什么？"></a>K8S是什么？</h2><section class="reference"></section><h5 id="特点"><a class="header-anchor" href="#特点"></a>特点</h5><section class="reference"><ul><li>可移植</li><li>可扩展</li><li>开源</li><li>生态系统庞大且有活力</li></ul></section><h5 id="作用"><a class="header-anchor" href="#作用"></a>作用</h5><section class="reference"><ul><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自动二进制打包</li><li>自我修复</li><li>秘钥与配置管理</li></ul></section><h5 id="其它意义"><a class="header-anchor" href="#其它意义"></a>其它意义</h5><section class="reference"><ul><li>促进声明式配置</li><li>自动化</li></ul></section><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="k8s架构图.png" alt="架构图" title="">                </div>                <div class="image-caption">架构图</div>            </figure></section><h2 id="组件"><a class="header-anchor" href="#组件"></a>组件</h2><section class="reference"><ul><li>Master【集群控制平面】<ul><li>kube-apiservice<ul><li>主节点上负责提供 Kubernetes API 服务的组件</li><li>支持<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/" target="_blank" rel="noopener">水平扩缩</a></li></ul></li><li><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/docs.md" target="_blank" rel="noopener">etcd</a><ul><li>作为保存 Kubernetes 所有集群数据的后台数据库</li><li>兼具一致性和高可用性的键值数据库</li><li>通常需要有个备份计划</li></ul></li><li>kube-scheduler<ul><li>监视新创建的未指定运行节点的 Pod</li><li>选择节点让 Pod 在上面运行</li></ul></li><li>kube-controller-manager<ul><li>Node Controller<ul><li>负责在节点故障时进行通知和响应</li></ul></li><li>Replication Controller（RC）<ul><li>负责为系统中每个副本控制器对象维护正确数量的 Pod</li></ul></li><li>Endpoints Controller<ul><li>填充端点（Endpoints）对象（即加入 Service 与 Pod）</li></ul></li><li>Service Account &amp; Token Controllers<ul><li>为新的命名空间创建默认账户和 API 访问令牌</li></ul></li></ul></li><li>cloud-controller-manager<ul><li>运行与基础云提供商交互的控制器</li></ul></li></ul></li></ul><p><img src="Master.png" alt="Master"></p><ul><li>Node【维护运行的 Pod 并提供 Kubernetes 运行环境】<ul><li>kubelet<ul><li>保证容器都运行在 Pod 中</li><li>接收一组通过各类机制提供给它的 PodSpecs，确保 PodSpecs 中描述的容器处于运行状态且健康</li><li>不会管理不是由 Kubernetes 创建的容器</li></ul></li><li>kube-proxy<ul><li>是集群中每个节点上运行的网络代理，实现 Kubernetes Service 概念的一部分</li><li>维护节点上的网络规则<ul><li>允许从集群内部或外部网络会话与 Pod 进行网络通信</li></ul></li></ul></li><li>容器运行环境（Docker 等）<ul><li>负责运行容器</li></ul></li></ul></li><li><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">Addons</a>【使用 Kubernetes 资源 (DaemonSet, Deployment等) 实现集群功能；命名空间为：kube-system】<ul><li>DNS<ul><li>所有 Kubernetes 集群都应具有 DNS (非强制性要求)</li><li>为 Kubernetes 集群提供 DNS 记录</li><li>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中</li></ul></li><li>Dashboard<ul><li><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">Web UI</a></li><li>使用户可以管理集群中运行的应用程序以及集群本身进行故障排除</li></ul></li><li>容器资源监控<ul><li>将关于容器的一些常见的时间序列度量值保存到一个集群数据库中</li><li>提供用于浏览这些数据的界面</li></ul></li><li>集群层面日志<ul><li>负责将容器的日志保存到一个集中的日志存储中</li><li>提供搜索和浏览接口</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Node.png" alt="Node" title="">                </div>                <div class="image-caption">Node</div>            </figure><p><strong><em>其他组件</em></strong></p><ul><li><a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" target="_blank" rel="noopener">kubectl</a>【操控 Kubernetes 集群】<ul><li>负责管理 Pods 和它们上面的容器，镜像、volumes、etc</li></ul></li></ul></section><h2 id="设计理念"><a class="header-anchor" href="#设计理念"></a>设计理念</h2><section class="reference"><div class="info"><p>核心理念：</p><ol><li>容错性</li><li>扩展性</li></ol></div></section><h5 id="api-设计原则"><a class="header-anchor" href="#api-设计原则"></a>API 设计原则</h5><section class="reference"><ol><li>所有 API 应该是声明式的</li><li>AIP 对象是彼此互补且可组合的</li><li>高层 API 以操作意图为基础设计</li><li>底层 API 根据高层 API 的控制需要设计</li><li>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏机制</li><li>API 操作复杂度与对象数量成正比</li><li>API 对象状态不能依赖于网络连接状态</li><li>尽量避免让操作机制依赖于全局状态</li></ol></section><h5 id="控制机制设计原则"><a class="header-anchor" href="#控制机制设计原则"></a>控制机制设计原则</h5><section class="reference"><ol><li>控制逻辑应该只依赖于当前状态</li><li>假设任何错误的可能，并做容错处理</li><li>尽量避免复杂状态机，控制逻辑不要依赖无法监控的内部状态</li><li>假设任何操作都可能被任何操作对象拒绝，甚至被错误解析</li><li>每个模块都可以在出错后自动恢复</li><li>每个模块都可以在必要的时候优雅的降级服务</li></ol></section><h5 id="核心技术概念"><a class="header-anchor" href="#核心技术概念"></a>核心技术概念</h5><section class="reference"><table><thead><tr><th>术语</th><th>语义</th><th>备注</th></tr></thead><tbody><tr><td>Pod</td><td>集群中部署应用或服务的最小单元，可以包含多个容器</td><td></td></tr><tr><td>副本集（Replica Set，RS）</td><td>新一代 RC，支持更多匹配模式</td><td></td></tr><tr><td>部署（Deployment）</td><td>表示用户对集群的一次更新操作</td><td></td></tr><tr><td>服务（Service）</td><td>客户端要访问的服务就是 Service 对象</td><td>每个 Service 会对应一个集群内部的虚拟 IP，集群内部通过虚拟 IP 访问服务</td></tr><tr><td>任务（Job）</td><td>控制批处理型任务的对象</td><td></td></tr><tr><td>后台支撑服务集（DaemonSet）</td><td>保证每个节点都有此类 Pod 运行</td><td>典型的支持服务有：存储、日志、监控等</td></tr><tr><td>有状态服务集（PetSet）</td><td>每个 Pod 的名字要事先确定，挂载自己独立的存储</td><td>适合 PetSet 的业务：MySQL、PostgreSQL、Zookeeper等</td></tr><tr><td>集群联邦（Federation）</td><td>提供扩区域跨服务商能力</td><td>每个 Federation 有自己的分布式存储、API Server 和 Controller Manager</td></tr><tr><td>存储卷（Volume）</td><td>与 Docker 存储卷类似，不过作用访问是 Pod</td><td></td></tr><tr><td>持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）</td><td>使集群具备存储的逻辑抽象能力</td><td>PV 和 PVC 的关系相当于 Node 和 Pod 的关系</td></tr><tr><td>名称（Names）</td><td>Kubernetes REST API 中的所有对象都由名称和 UID 明确标识；一次只能有一个给定类型的对象具有给定的名称（如果删除对象，则可以创建同名的新对象）</td><td></td></tr><tr><td>UIDs</td><td>系统生成的字符串，唯一标识对象；在集群的整个生命周期中创建的每一个对象都有一个不同的 UID，用来区分类似实体的历史事件</td><td></td></tr><tr><td>命名空间（Namespace）</td><td>Kubernetes 支持多个虚拟集群，依赖于同一物理集群。这些虚拟集群被称为命名空间。</td><td></td></tr><tr><td>标签和选择器（Labels &amp; Selectors）</td><td>标签是附加到 Kubernetes 对象上的键值对，用于指定对用户有意义且相关的对象标识属性，但不直接对核心系统有语义含义</td><td>每个对象都可以定义一组键/值标签，每个键对于给定对象必须唯一</td></tr><tr><td>注解（Annotations）</td><td>可以使用注解为对象附加任意的非标识的元数据</td><td></td></tr><tr><td>字段选择器（Field Selectors）</td><td>允许根据多个或多个资源字段的值筛选 Kubernetes 资源</td><td></td></tr></tbody></table></section><h2 id="kubernetes-对象管理"><a class="header-anchor" href="#kubernetes-对象管理"></a>Kubernetes 对象管理</h2><section class="reference"><div class="warning"><p>应该只使用一种技术来管理 Kubernetes 对象；混合和匹配技术作用于同一对象上将导致未定义行为</p></div><table><thead><tr><th>类型</th><th>使用环境</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>命令式命令</td><td>测试</td><td>1. 命令简单，易学、易记；</br>2. 快速更改集群</td><td>1. 命令不与变更审查流程集成；<br>2. 不提供与更改管理的审核跟踪；<br>3.除了实时内容，命令不提供记录源；<br>4. 不提供用于创建新对象的模板</td></tr><tr><td>命令式对象配置</td><td>生产</td><td>与命令式命令相比：<br>1. 可以存储在源控制系统中，如：Git；<br>2. 可以与流程集成，如：在推送和审计之前检查更新；<br>3.提供用于创建新对象的模板；<br><br>与声明式对象配置相比：<br>1. 配置行为简单易懂；<br>2. 更加成熟</td><td>与命令式命令相比：<br>1. 需要对对象架构有了解；<br>2. 需要些 YAML 文件；<br><br>与声明式对象配置相比：<br>1. 对活动对象的更新必须反映在配置文件中，否则将在下一次替换时丢失；<br>2. 针对文件而不是目录</td></tr><tr><td>声明式对象配置</td><td>生产</td><td>1. 即使未将对活动对象所做的更改未合并回配置文件中，也将保留这些更改；<br>2. 更好的支持对目录进行操作并自动检测每个对象的操作类型（创建、修补、删除）</td><td>1. 配置难于调试并且出现异常时难以理解；<br>2. 使用差异的部分更新会创建复杂的合并和补丁操作</td></tr></tbody></table></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h5 id="安装"><a class="header-anchor" href="#安装"></a>安装</h5><section class="sample"><pre><code>cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial mainEOFapt-get updateapt-get install -y kubelet kubeadm kubectlapt-mark hold kubelet kubeadm kubectl</code></pre></section><section class="reference"><p><strong><em>参考资料</em></strong><br><a href="https://kubernetes.io/zh/docs/concepts/" target="_blank" rel="noopener">K8S(官方)</a><br><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes 中文社区 | 中文文档</a><br><a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">Kubernetes 中文手册</a></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 编排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK</title>
      <link href="/2019/12/20/DevOps/ELK/"/>
      <url>/2019/12/20/DevOps/ELK/</url>
      
        <content type="html"><![CDATA[<h2 id="elk-是什么"><a class="header-anchor" href="#elk-是什么"></a>ELK 是什么?</h2><section class="reference"><ul><li>是 ElasticSearch、Logstash、Kibana 三个开源软件的组合</li><li>具备数据收集、存储、分析功能</li><li>适合实时数据分析和检索的场景</li><li>具有分布式特性</li><li>易扩展</li></ul></section><h2 id="elk-功能"><a class="header-anchor" href="#elk-功能"></a>ELK 功能</h2><section class="reference"><ul><li>ElasticSearch<ul><li>存储</li><li>索引</li></ul></li><li>Logstash<ul><li>收集</li><li>处理</li></ul></li><li>Kibana<ul><li>可视化</li><li>统计分析</li></ul></li><li>Beat（扩展组件）<ul><li>MetricBeat<ul><li>收集各种主机信息（CPU、内存……），详见官网</li></ul></li><li>Filebeat<ul><li>轻量级日志收集组件</li></ul></li></ul></li></ul></section><h2 id="简单架构"><a class="header-anchor" href="#简单架构"></a>简单架构</h2><section class="reference"><div id="flowchart-0" class="flow-chart"></div></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="使用-docker-安装-elk"><a class="header-anchor" href="#使用-docker-安装-elk"></a>使用 Docker 安装 ELK</h4><section class="reference"><p>参考 <a href="https://github.com/deviantony/docker-elk.git" target="_blank" rel="noopener">https://github.com/deviantony/docker-elk.git</a></p><div class="info"><ul><li>Kibana 中文设置<br><code>$ vim kibana/config/kibana.yml</code></li><li>新增中文配置 ↓↓↓</li><li>i18n.locale: “zh-CN”</li></ul></div><div class="warning"><ul><li>ElasticSearch 默认需要 4G 内存；可以通过设置 ES_JAVA_OPTS 来修改</li><li>如：<code>ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot;</code></li></ul></div></section><h4 id="使用-docker-安装-metricbeat"><a class="header-anchor" href="#使用-docker-安装-metricbeat"></a>使用 Docker 安装 MetricBeat</h4><section class="sample"><p><strong><em>获取配置文件</em></strong></p><ul><li>下载 <code>$ wget https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-7.4.1-linux-x86_64.tar.gz</code></li><li>解压 <code>$ tar zxvf metricbeat-7.4.1-linux-x86_64.tar.gz</code></li><li>提取 <code>metricbeat.yml modules.d</code></li></ul><p><strong><em>使用 Docker Compose</em></strong><br><code>$ vim docker-compose.yml</code></p><pre><code class="language-yml">version: '2'services:  metricbeat:    image: docker.elastic.co/beats/metricbeat:7.4.1    container_name: metricbeat    volumes:      - /var/run/docker.sock:/var/run/docker.sock:ro      - /proc:/hostfs/proc:ro      - /sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro      - /:/hostfs:ro      - ./metricbeat/metricbeat.yml:/usr/share/metricbeat/metricbeat.yml:ro      - ./metricbeat/modules.d:/usr/share/metricbeat/modules.d:ro      -  /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro    user: &quot;root&quot;    command: -system.hostfs=/hostfs -e    restart: always</code></pre></section><section class="reference"><p><code>docker exec -it metricbeat metricbeat modules enable system</code><script src="https://cdn.bootcss.com/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.12.2/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op0=>operation: Data（Log）op1=>operation: MetricBeatop2=>operation: Redisop3=>operation: Logstashop4=>operation: ElasticSearchop5=>operation: Kibanaop0(right)->op2op1(right)->op4op2(right)->op3op3(right)->op4op4(right)->op5</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> Logstash </tag>
            
            <tag> Kibana </tag>
            
            <tag> MetricBeat </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zabbix</title>
      <link href="/2019/12/13/DevOps/Zabbix/"/>
      <url>/2019/12/13/DevOps/Zabbix/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-zabbix-？"><a class="header-anchor" href="#什么是-zabbix-？"></a>什么是 Zabbix ？</h2><section class="reference"><p>Zabbix 是一种系统监控。网络监控、服务监控工具。</p></section><h4 id="监控对象"><a class="header-anchor" href="#监控对象"></a>监控对象</h4><section class="reference"><ul><li>主机</li><li>软件</li></ul></section><h4 id="模块功能"><a class="header-anchor" href="#模块功能"></a>模块功能</h4><section class="reference"><ul><li>Monitoring<ul><li>信息聚合</li><li>状态展示</li><li>信息查询</li><li>监控统计</li></ul></li><li>Inventory<ul><li>资产信息<ul><li>管理</li><li>查询</li></ul></li></ul></li><li>Report<ul><li>报表</li><li>审计</li><li>日志</li></ul></li><li>Configuration<ul><li>主机信息配置</li><li>监控规则配置</li><li>报警规则配置</li><li>统计图表配置</li><li>自动发现配置</li></ul></li><li>Administrator<ul><li>用户权限管理</li><li>报警方式配置</li><li>脚本配置</li><li>代理配置</li></ul></li><li>Personal<ul><li>接收报警配置</li><li>接收报警规则</li><li>个人信息管理</li></ul></li></ul></section><h2 id="zabbix-特点"><a class="header-anchor" href="#zabbix-特点"></a>Zabbix 特点</h2><section class="reference"><ul><li>安装简单</li><li>监控方便</li><li>免费开源</li><li>自动化</li><li>C/S 结构、分布式架构</li></ul></section><h2 id="与同类型比较"><a class="header-anchor" href="#与同类型比较"></a>与同类型比较</h2><section class="reference"><table><thead><tr><th>系统名称</th><th>默认监控</th><th>自定义监控</th><th>批量监控</th><th>修改监控</th><th>图表</th><th>报警</th><th>其他</th></tr></thead><tbody><tr><td>Zabbix</td><td>自带监控多</td><td>可自定义编写插件</td><td>server 端可配置自动注册规则；client 端无需操作</td><td>手动在模板中新增监控</td><td>自带图表插件</td><td>支持多种报警，依赖插件</td><td>自带 Web 监控</td></tr><tr><td>Nagios</td><td>自带监控少</td><td>可自定义编写插件</td><td>用脚本在 server 端新增 host， 并拷贝 service 文件</td><td>用脚本修改所有主机的 service 文件，加入新增服务</td><td>可以按照图表插件</td><td>支持多种报警，依赖插件</td><td></td></tr></tbody></table><hr><div class="info"><ul><li>Zabbix 使用更友好，探索功能需要较多时间，学习成本较大</li><li>Nagios 容易上手，脚本很强大，但写起来也费时费力</li></ul></div></section><h2 id="架构图"><a class="header-anchor" href="#架构图"></a>架构图</h2><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/Zabbix架构.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h4 id="部署方式"><a class="header-anchor" href="#部署方式"></a>部署方式</h4><section class="reference"><ul><li>网络协议模式：server-client</li><li>代理模式：server-proxy-client</li><li>节点模式：master-node-client</li></ul></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="安装"><a class="header-anchor" href="#安装"></a>安装</h4><section class="reference"><ol><li>打开<a href="https://www.zabbix.com/download" target="_blank" rel="noopener">官网下载页面</a></li><li>选择操作系统</li><li>按引导安装<ol><li>安装 Server 端<ol><li>添加源</li><li>安装 Server</li><li>安装 MySQL</li><li>初始化 MySQL</li><li>启动 zabbix-server</li></ol></li><li>安装 Web 端<ol><li>安装 Web</li><li>配置 timezone：<ol><li><code>$ vim /etc/php-fpm.d/zabbix.conf</code></li><li><code>; php_value[date.timezone] = Asian/Shanghai</code></li></ol></li><li>启动 [httpd|nginx|apache2] php-fpm</li><li>打开 <code>http://[ip]/zabbix</code><ol><li>默认用户密码：<code>Admin : zabbix</code></li></ol></li></ol></li><li>安装 Agent 端<ol><li>添加源</li><li>安装 Agent</li><li>配置连接的 Server<ol><li><code>$ vim /etc/zabbix/zabbix_agentd.conf</code></li></ol></li><li>启动 zabbix-agent</li></ol></li></ol></li></ol><p><strong><em>踩坑指南</em></strong></p><div class="warning"><ul><li>Mariadb 代替 MySQL</li><li>关闭 SeLinux，否则可能出现：cannot set resource limit</li><li>默认使用 httpd 作为 Web 服务</li></ul></div></section><h4 id="web-使用"><a class="header-anchor" href="#web-使用"></a>Web 使用</h4><section class="reference"><p><strong><em>配置自动发现</em></strong></p><div id="flowchart-0" class="flow-chart"></div><p><strong><em>配置报警</em></strong></p><div id="flowchart-1" class="flow-chart"></div><p><strong><em>配置发送报警</em></strong></p><div id="flowchart-2" class="flow-chart"></div><p><strong><em>配置接收报警</em></strong></p><div id="flowchart-3" class="flow-chart"></div><p><strong><em>配置统计图表</em></strong></p><div id="flowchart-4" class="flow-chart"></div><p><strong><em>配置聚合图表</em></strong></p><div id="flowchart-5" class="flow-chart"></div><p><strong><em>用户管理</em></strong></p><div id="flowchart-6" class="flow-chart"></div><p><strong><em>配置聚合图表</em></strong></p><div id="flowchart-7" class="flow-chart"></div></section><h4 id="通用设置套路"><a class="header-anchor" href="#通用设置套路"></a>通用设置套路</h4><section class="reference"><div id="flowchart-8" class="flow-chart"></div></section><h4 id="web-api"><a class="header-anchor" href="#web-api"></a>Web API</h4><section class="reference"></section><h5 id="功能"><a class="header-anchor" href="#功能"></a>功能</h5><section class="reference"><ul><li>远程管理 Zabbix 配置</li><li>远程检索配置和历史数据</li></ul></section><h5 id="接入方式"><a class="header-anchor" href="#接入方式"></a>接入方式</h5><section class="reference"><ul><li><code>http://[ip]:[port]/zabbix/api_jsonrpc.php</code><ul><li>使用 JSON-RPC 实现</li><li>数据传输以 JSON 格式</li></ul></li><li>Headers<ul><li><code>Content-Type: application/json-rpc</code></li><li><code>Content-Type: application/json</code></li><li><code>Content-Type: application/jsonrequest</code></li></ul></li></ul></section><h5 id="接入步骤"><a class="header-anchor" href="#接入步骤"></a>接入步骤</h5><section class="reference"><ul><li>登录获取 token</li><li>请求头带入 Authorization: [token]</li></ul><p><strong><em>参考资料</em></strong><br><a href="https://coding.imooc.com/class/239.html#Anchor" target="_blank" rel="noopener">中小型企业通用自动化运维架构</a><br><a href="https://blog.csdn.net/u010285974/article/details/86702421" target="_blank" rel="noopener">zabbix与nagios对比</a><script src="https://cdn.bootcss.com/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.12.2/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: Configurationop2=>operation: Discovery   op3=>operation: Create Discovery Rulesop4=>operation: Create Rulesop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: Configurationop2=>operation: Create Action   op3=>operation: Create Conditionop4=>operation: Create Operationop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: Administratorop2=>operation: Media Typeop3=>operation: Emailop4=>operation: Updateop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">op1=>operation: Administratorop2=>operation: Usersop3=>operation: Adminop4=>operation: Mediaop5=>operation: Addop1(right)->op2op2(right)->op3op3(right)->op4op4(right)->op5</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">op1=>operation: Configurationop2=>operation: Hostsop3=>operation: Graphsop4=>operation: 条目选择op1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-4-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">op1=>operation: Monitoringop2=>operation: Screensop3=>operation: Addop4=>operation: Edit Screenop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-5-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script><textarea id="flowchart-6-code" style="display: none">op1=>operation: Administratorop2=>operation: Usersop3=>operation: User Groupsop1(right)->op2op2(right)->op3</textarea><textarea id="flowchart-6-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-6-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-6-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-6", options);</script><textarea id="flowchart-7-code" style="display: none">op1=>operation: Monitoringop2=>operation: Screensop3=>operation: Addop4=>operation: Edit Screenop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-7-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-7-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-7-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-7", options);</script><textarea id="flowchart-8-code" style="display: none">op1=>operation: 创建监控脚本op2=>operation: 创建 Zabbix Itemop3=>operation: 创建 Zabbix Triggerop4=>operation: 创建 Zabbix Actionop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-8-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-8-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-8-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-8", options);</script></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Zabbix </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算</title>
      <link href="/2019/12/10/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/12/10/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><section class="reference"><p>云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。<br>现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。</p></section><h2 id="特点"><a class="header-anchor" href="#特点"></a>特点</h2><section class="reference"><ul><li>虚拟化(计算、存储、网络等)</li><li>产品服务化(IaaS、PaaS、SaaS……)</li><li>弹性伸缩</li></ul></section><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><section class="reference"><ul><li>基础设施层(IaaS)</li><li>平台层(PaaS)</li><li>软件服务层(SaaS)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/云架构.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="分类"><a class="header-anchor" href="#分类"></a>分类</h2><section class="reference"><ul><li>私有云</li><li>公有云</li><li>混合云</li></ul><p><strong><em>荤段子论</em></strong></p><blockquote><p>男人找个女友或老婆是自建<strong>私有云</strong>，单身约炮或者到娱乐场所消费是<strong>公有云</strong>服务，按需使用并可弹性扩容，已婚男人找二奶小蜜则属于<strong>混合云</strong>。</p></blockquote></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps</title>
      <link href="/2019/12/09/DevOps/DevOps/"/>
      <url>/2019/12/09/DevOps/DevOps/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a class="header-anchor" href="#前置知识"></a>前置知识</h2><section class="reference"><a href="/2019/12/10/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97/" title="云计算">云计算</a></section><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><section class="reference"><p><code>DevOps = Development(开发人员) + Operations(运维人员)</code></p><p>DevOps 是一种重视“开发人员”和“运维人员”之间沟通合作的文化、运动或者惯例。通过自动化“软件交付”和“架构变更”的流程，使构建、测试、发布软件能更快、更频繁和更可靠。</p><p><strong><em>各部门关系图</em></strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/DevOps.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="对应用程序发布的影响"><a class="header-anchor" href="#对应用程序发布的影响"></a>对应用程序发布的影响</h2><section class="reference"><ul><li>减少变更范围</li><li>消除等待、快速反馈</li><li>使问题定位、调试变得简单</li><li>加强发布谐调，提升交付质量</li><li>自动化，稳定、快速、交付结果可预测</li><li>资源利用最大化</li></ul></section><h2 id="关键点"><a class="header-anchor" href="#关键点"></a>关键点</h2><section class="reference"><blockquote><ol><li>Automated infrastructure（自动化，系统之间的集成）</li><li>shared version control（SVN共享源码）</li><li>one step build and deploy（持续构建和部署）</li><li>feature flags（主干开发）</li><li>Shared metrics</li><li>IRC and IM robots（信息整合）</li></ol></blockquote><ul><li>CI/CD 一线贯穿以上技术要点</li><li>主干开发是 CI 的前提</li><li>自动化以及代码周边集中管理是实施 CI 的必要条件</li></ul><div class="warning"><p>CI/CD 是 DevOps 的技术核心，在没有自动化测试、CI/CD 之下，DevOps 就是空中楼阁</p></div></section><h2 id="工作流"><a class="header-anchor" href="#工作流"></a>工作流</h2><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/DevOps回路.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="工具箱"><a class="header-anchor" href="#工具箱"></a>工具箱</h2><section class="reference"><ul><li>代码管理（SCM）<ul><li>GitHub、GitLab、BitBucket、SubVersion</li></ul></li><li>构建工具<ul><li>Ant、Gradle、maven</li></ul></li><li>自动部署<ul><li>Capistrano、CodeDeploy、Ansible、Jenkins</li></ul></li><li>持续集成（CI）<ul><li>Bamboo、Hudson、Jenkins</li></ul></li><li>配置管理<ul><li>Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail、Consul、Apollo</li></ul></li><li>容器<ul><li>Docker、LXC、第三方厂商如AWS</li></ul></li><li>编排<ul><li>Kubernetes、Core、Apache Mesos、DC/OS</li></ul></li><li>服务注册与发现<ul><li>Zookeeper、etcd、Consul</li></ul></li><li>脚本语言<ul><li>python、ruby、shell</li></ul></li><li>日志管理<ul><li>ELK、Logentries</li></ul></li><li>系统监控<ul><li>Datadog、Graphite、Icinga、Nagios</li></ul></li><li>性能监控<ul><li>AppDynamics、New Relic、Splunk</li></ul></li><li>压力测试<ul><li>JMeter、Blaze Meter、<a href="http://loader.io" target="_blank" rel="noopener">loader.io</a></li></ul></li><li>预警<ul><li>PagerDuty、pingdom、厂商自带如AWS SNS</li></ul></li><li>HTTP加速器<ul><li>Varnish</li></ul></li><li>消息总线<ul><li>ActiveMQ、SQS</li></ul></li><li>应用服务器<ul><li>Tomcat、JBoss</li></ul></li><li>Web服务器<ul><li>Apache、Nginx、IIS</li></ul></li><li>数据库<ul><li>MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</li></ul></li><li>项目管理（PM）<ul><li>Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker</li></ul></li></ul><p><strong><em>参考链接</em></strong><br><a href="https://www.jianshu.com/p/47287f203637" target="_blank" rel="noopener">给 DevOps 初学者的入门指南</a></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible</title>
      <link href="/2019/12/09/DevOps/Ansible/"/>
      <url>/2019/12/09/DevOps/Ansible/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-ansible-？"><a class="header-anchor" href="#什么是-ansible-？"></a>什么是 Ansible ？</h2><section class="reference"><ul><li>是一种 IT 自动化工具</li><li>依赖现有的操作系统的凭证来访问控制远程机器</li><li>简单易用、安全可靠</li></ul></section><h2 id="ansible-可以完成哪些任务？"><a class="header-anchor" href="#ansible-可以完成哪些任务？"></a>Ansible 可以完成哪些任务？</h2><section class="reference"><ul><li>系统配置</li><li>开发软件</li><li>编排高级的 IT 任务（持续集成等）</li></ul></section><h2 id="ansible-的优点"><a class="header-anchor" href="#ansible-的优点"></a>Ansible 的优点</h2><section class="reference"><ul><li>轻量级</li><li>易学习</li><li>操作灵活</li><li>无客户端</li><li>推送式</li><li>Module 丰富</li><li>商业化支持（Tower）</li></ul></section><h2 id="ansible-的缺点"><a class="header-anchor" href="#ansible-的缺点"></a>Ansible 的缺点</h2><section class="reference"><ul><li>效率低（串行执行）</li><li>易挂起</li></ul></section><h2 id="与其他类似项目对比"><a class="header-anchor" href="#与其他类似项目对比"></a>与其他类似项目对比</h2><section class="reference"><table><thead><tr><th>项目</th><th>客户端</th><th>通信方式</th><th>Web 页面</th><th>效率</th><th>易用</th><th>实现语言</th><th>API</th><th>开源社区</th></tr></thead><tbody><tr><td>Ansible</td><td>无</td><td>ssh</td><td>有（Tower）</td><td>低</td><td>高</td><td>Python</td><td>有</td><td>40.8 K</td></tr><tr><td>Puppet</td><td>有</td><td>socket</td><td>有</td><td>一般</td><td>低</td><td>Ruby</td><td>有</td><td>5.6 K</td></tr><tr><td>Chef</td><td>有</td><td>ssh</td><td>有</td><td>一般</td><td>高</td><td>Python</td><td>有</td><td>6.1 K</td></tr><tr><td>Salt</td><td>有</td><td>RabbitMQ</td><td>有</td><td>高</td><td>高</td><td>Python</td><td>有</td><td>10.5 K</td></tr></tbody></table></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h3 id="安装"><a class="header-anchor" href="#安装"></a>安装</h3><section class="reference"><ul><li>Mac: <code>pip install ansible</code></li></ul></section><h3 id="配置"><a class="header-anchor" href="#配置"></a>配置</h3><section class="reference"><ul><li>Host 配置: <code>/etc/ansible/hosts</code><ul><li>配置项: <a href="https://docs.ansible.com/ansible/2.4/ansible-inventory.html" target="_blank" rel="noopener">Inventory</a> | <a href="http://www.ansible.com.cn/docs/intro_inventory.html" target="_blank" rel="noopener">Inventory 中文</a></li></ul></li><li>ssh 配置: <code>ssh-copy-id -i .ssh/[公钥文件] [用户]@[远程主机]</code></li></ul></section><h3 id="ad-hoc-playbook"><a class="header-anchor" href="#ad-hoc-playbook"></a>Ad-Hoc &amp; Playbook</h3><section class="reference"><ul><li>类似 <code>shell</code> &amp; <code>shell script</code>，但 Playbook 更加强大</li><li>Playbook 是对 Ad-Hoc 的编排</li><li>Ad-Hoc 适合简单快速的任务</li><li>Playbook 适合复杂异步的任务</li><li>Playbook 解决 shell script 的编写复杂、操作繁琐、跨平台问题</li></ul></section><h4 id="ad-hoc"><a class="header-anchor" href="#ad-hoc"></a>Ad-Hoc</h4><section class="reference"></section><h5 id="语法"><a class="header-anchor" href="#语法"></a>语法</h5><section class="reference"><p><code>ansible [远程主机 | 分组] -m [模块] -a '模块参数'</code></p></section><h4 id="playbook"><a class="header-anchor" href="#playbook"></a>Playbook</h4><section class="reference"></section><h5 id="什么是-playbook"><a class="header-anchor" href="#什么是-playbook"></a>什么是 Playbook ?</h5><section class="reference"><ul><li>由 YAML 编写</li><li>算是一门编程语言</li><li>命令集合</li></ul></section><h5 id="功能"><a class="header-anchor" href="#功能"></a>功能</h5><section class="reference"><ul><li>声明配置</li><li>编排复杂任务</li><li>控制任务执行</li></ul></section><h5 id="语法-v2"><a class="header-anchor" href="#语法-v2"></a>语法</h5><section class="reference"><ul><li>变量（Inventory &amp; Playbook）<ul><li>vars</li></ul></li><li>流程控制<ul><li>循环<ul><li>with_items</li><li>with_nested (嵌套)</li></ul></li><li>判断<ul><li>when [true, false, not]</li></ul></li></ul></li></ul></section><h5 id="基本结构"><a class="header-anchor" href="#基本结构"></a>基本结构</h5><section class="sample"><ul><li>host: 被操作的机器</li><li>remote_user: 登录机器的用户</li><li>tasks: 需要执行的任务</li></ul><div class="warning"><p>如果语句以 “{” 开头，需要用<strong>引号</strong>包起来</p></div><p><strong><em>例子</em></strong><br><code>$ vim test.yml</code></p><pre><code>---- hosts: 192.168.1.111                      // 指定主机  remote_user: root                       // 指定在被管理的主机上执行任务的用户  tasks:                                  // 任务列表  - name: disable selinux                // 任务名    command: '/sbin/setenforce 0'        // 调用command模块 执行关闭防火墙命令  - name: start nginx                    // 任务名    service: name=nginx state=started    // 调用service模块 开启 nginx 服务</code></pre></section><section class="reference"><p><code>$ ansible-playbook test.yml</code></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible </tag>
            
            <tag> 自动化 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹性伸缩</title>
      <link href="/2019/12/09/Aliyun/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/"/>
      <url>/2019/12/09/Aliyun/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="能力"><a class="header-anchor" href="#能力"></a>能力</h2><section class="reference"><p>根据业务需求和策略自动调整弹性计算资源，在业务需求增长时无缝增加 ECS 实例满足计算需要，在业务需求下降时自动减少 ECS 实例节约成本。</p></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h4><section class="reference"><div id="flowchart-0" class="flow-chart"></div><script src="https://cdn.bootcss.com/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.12.2/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 创建伸缩组op2=>operation: 创建伸缩配置    op3=>operation: 启用伸缩组op4=>operation: 创建伸缩规则op5=>operation: 创建定时任务op6=>operation: 创建报警任务op1(right)->op2op2(right)->op3op3(right)->op4op4(right)->op5op5(right)->op6</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></section>]]></content>
      
      
      <categories>
          
          <category> 阿里云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 弹性伸缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-部署-Jenkins</title>
      <link href="/2019/12/09/DevOps/Docker-%E9%83%A8%E7%BD%B2-Jenkins/"/>
      <url>/2019/12/09/DevOps/Docker-%E9%83%A8%E7%BD%B2-Jenkins/</url>
      
        <content type="html"><![CDATA[<h2 id="部署"><a class="header-anchor" href="#部署"></a>部署</h2><section class="reference"></section><h4 id="dockerfile"><a class="header-anchor" href="#dockerfile"></a>Dockerfile</h4><section class="sample"><pre><code>FROM jenkins/jenkins:ltsMAINTAINER LockeyUSER rootARG dockerGid=999RUN echo &quot;docker:x:${dockerGid}:jenkins&quot; &gt;&gt; /etc/group</code></pre></section><section class="reference"></section><h4 id="构建"><a class="header-anchor" href="#构建"></a>构建</h4><section class="reference"><p><code>docker build . -t myjenkins</code></p></section><h4 id="运行"><a class="header-anchor" href="#运行"></a>运行</h4><section class="reference"><p><code>docker run -d --privileged=true -p 8005:8080 -p 50000:50000 --name myjenkins_1 -v /root/jenkins:/var/jenkins_home -v /root/.ssh:/var/jenkins_home/.ssh -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/docker:/var/lib/docker -v $(which docker):/usr/bin/docker -v $(which docker-compose):/usr/bin/docker-compose myjenkins</code></p></section><h2 id="slave"><a class="header-anchor" href="#slave"></a>Slave</h2><section class="reference"><ul><li>安装Java(8)<ul><li>apt install openjdk-8-jre-headless</li></ul></li><li>配置免密登录<ul><li>ssh-keygen -t rsa</li></ul></li></ul><p><strong><em>注意</em></strong></p><ul><li>.ssh文件挂载<ul><li>Git访问</li><li>Slave访问</li></ul></li><li>Dockerfile<ul><li>将用户加入docker用户组，不然没有Docker访问权限</li></ul></li></ul></section><h2 id="更换源-国内"><a class="header-anchor" href="#更换源-国内"></a>更换源【国内】</h2><section class="reference"><p>打开： <code>http[s]://[URL]/pluginManager/advanced</code></p><p>替换升级站点URL：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></p><p>PS：如果出现更换后还是走了官方源，可以配置 Nginx：<br><code>rewrite ^/download/plugins/(.*)$ https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/$1? last;</code></p></section>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook</title>
      <link href="/2019/12/05/Gitbook/"/>
      <url>/2019/12/05/Gitbook/</url>
      
        <content type="html"><![CDATA[<h2 id="dockerfile"><a class="header-anchor" href="#dockerfile"></a>Dockerfile</h2><section class="sample"><pre><code>FROM nodeWORKDIR /buildEXPOSE 4000RUN npm install gitbook -g;RUN npm install gitbook-cli -g;WORKDIR /build/workRUN gitbook initCMD [&quot;gitbook&quot;, &quot;serve&quot;]</code></pre></section><section class="reference"></section><h2 id="构建"><a class="header-anchor" href="#构建"></a>构建</h2><section class="reference"><p><code>$ docker build . -t acgitbook</code></p></section><h2 id="运行"><a class="header-anchor" href="#运行"></a>运行</h2><section class="reference"><p><code>$ docker run -d --name acgitbook_1 -p 8006:4000 -v /root/jenkins/workspace/acdocs/work:/build/work acgitbook /bin/bash -c &quot;gitbook install;gitbook serve&quot;</code></p></section>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 文档管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
