<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lockey</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lockey.xyz/"/>
  <updated>2020-04-23T03:34:24.810Z</updated>
  <id>http://www.lockey.xyz/</id>
  
  <author>
    <name>Lockey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统基础</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-22T09:12:30.000Z</published>
    <updated>2020-04-23T03:34:24.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><section class="reference"><ul><li>进程地址空间（进程虚拟地址）<ul><li>用户空间与内核空间（Linux）<ul><li>内核可以访问受保护内存空间，也有访问底层所有设备的权限</li><li>为了保证内核安全（保证用户进程不能直接操作内核），将虚拟空间划分为用户空间和内核空间</li><li>32位操作系统：2^32 = 4GB；内核空间 1GB（从虚拟地址0xC0000000到0xFFFFFFFF），用户空间 3GB（从虚拟地址0x00000000到0xBFFFFFFF）</li><li>64位操作系统：2^48（不需要64那么大、过大会导致资源浪费） = 256T；内核、用户空间分别占128T</li></ul></li></ul></li><li>进程切换（任何进程都在操作系统的内核支持下运行）<ul><li>可以挂起在 CPU 上运行的进程<ul><li>保存上下文（计数器、寄存器等）</li><li>更新 PCB（进程控制块）信息</li><li>把进程 PCB 移入相应的队列（就绪、在某事件阻塞等队列）</li></ul></li><li>可以恢复以前挂起的进程<ul><li>选择一个进程执行，更新其 PCB</li><li>更新内存管理的数据结构</li><li>恢复上下文</li></ul></li></ul></li><li>进程阻塞、唤醒<ul><li>进程状态<ul><li>运行态：进程获得 CPU 并运行</li><li>就绪态：进程具备运行条件，但尚未获得 CPU</li><li>阻塞态：进程因等待某事件发生而暂时不能运行</li></ul></li><li>正在运行的进程，由于提出系统服务请求（如 I/O 操作）未得到系统的立即响应，该进程会调用阻塞原语把自己阻塞，等待相应事件出现后被唤醒</li><li>只有处于获得 CPU 的进程才能将其转换为阻塞状态</li><li>阻塞<ul><li>请求系统服务、I/O 操作等未得到即时响应</li><li>找到要被阻塞进程的标识号对应的 PCB</li><li>停止执行</li><li>若该进程为运行状态（获得 CPU），则保护现场，改变状态为阻塞状态</li><li>把 PCB 插入相应阻塞队列</li></ul></li><li>唤醒<ul><li>阻塞原因期待的事件出现</li><li>把被阻塞的进程移出阻塞队列</li><li>将 PCB 状态改为就绪状态</li><li>将 PCB 插入到就绪队列中</li></ul></li></ul></li><li>文件描述符（FD）（适用于 Unix、Linux；Windows 中通常叫 Handle）<ul><li><strong>在 Linux 中，一切皆文件</strong><ul><li>对所有文件（目录、字符设备、块设备、套接字、打印机、进程、线程、管道等）操作，读写都可用fopen()/fclose()/fwrite()/fread()等函数进行处理</li></ul></li><li>用于表述指向文件的引用的抽象化概念</li><li>标准文件描述符<ul><li>0：标准输入；1：标准输出；2：标准错误</li></ul></li></ul></li><li>缓存 I/O（标准I/O）<ul><li>工作过程<ul><li>Linux 中，操作系统会将 I/O 的数据缓存在文件系统的页缓存中<ul><li>数据先被拷贝到操作系统内核缓冲区中</li><li>再从内核缓冲区拷贝到应用程序地址空间</li></ul></li></ul></li><li>缺点：开销大</li><li>基于缓存 I/O 出现的模型<ul><li>阻塞 I/O</li><li>非阻塞 I/O</li><li>I/O 多路复用</li><li>信号驱动 I/O（不常用）</li><li>异步 I/O</li></ul></li></ul></li></ul><p><a href="https://www.iminho.me/wiki/blog-23.html" target="_blank" rel="noopener">IO多路复用原理剖析</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;进程地址空间（进程虚拟地址）
&lt;ul&gt;
&lt;li&gt;用户空间与内核空间（Linux）
&lt;u
      
    
    </summary>
    
    
      <category term="基础" scheme="http://www.lockey.xyz/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="操作系统" scheme="http://www.lockey.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>内核网络数据收发流程</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B/</id>
    <published>2020-04-22T09:10:26.000Z</published>
    <updated>2020-04-23T02:30:09.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置基础"><a class="header-anchor" href="#前置基础"></a>前置基础</h2><section class="reference"><p>→ <a href="/2020/04/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" title="操作系统基础">操作系统基础</a> ←<br>→ <a href="/2020/04/22/%E5%9F%BA%E7%A1%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD/" title="Linux内核中断">Linux内核中断</a> ←</p></section><h2 id="网卡-nic"><a class="header-anchor" href="#网卡-nic"></a>网卡（NIC）</h2><section class="reference"><p>网卡是一块被设计用来<strong><em>允许计算机在计算机网络上进行通讯的计算机硬件</em></strong>。由于其拥有 MAC 地址，因此属于 OSI 模型的第 2 层。它使得用户可以通过电缆或无线相互连接。每一个网卡都有一个被称为 MAC 地址的独一无二的48位串行号，它被写在卡上的一块 ROM 中。在网络上的每一个计算机都必须拥有一个独一无二的 MAC 地址。没有任何两块被生产出来的网卡拥有同样的地址。这是因为电气电子工程师协会（IEEE）负责为网络接口控制器（网卡）销售商分配唯一的 MAC 地址。</p></section><h2 id="网卡驱动"><a class="header-anchor" href="#网卡驱动"></a>网卡驱动</h2><section class="reference"><p>驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器—— CPU 控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。所有的硬件都要安装驱动程序，没有驱动程序的硬件是运行不了的，就像一辆有轮胎但是没有传动轴的汽车一样跑不起来，控制不了。假如某设备的驱动程序未能正确安装，便不能正常工作。</p><p>「网卡驱动」程序就是 CPU 控制和使用网卡的程序。</p></section><h4 id="网卡驱动处理数据的方式"><a class="header-anchor" href="#网卡驱动处理数据的方式"></a>网卡驱动处理数据的方式</h4><section class="reference"></section><h5 id="napi-主流"><a class="header-anchor" href="#napi-主流"></a>NAPI（主流）</h5><section class="reference"><p>NAPI 是「中断」和「轮询」的结合体，避开了单轮询的无效做功和单中断的数据量大时频繁中断的消耗。在数据量少是使用中断，数据量多时使用轮询。平时是中断模式，当有数据到达时，会触发中断处理函数，中断处理函数关闭中断开始处理，此时再有数据过来，就不会触发中断，因为中断处理函数中会采用轮询的方式处理数据，直到没有新数据才重新打开中断。</p></section><h5 id="napi-的缺陷"><a class="header-anchor" href="#napi-的缺陷"></a>NAPI 的缺陷</h5><section class="reference"><ol><li>不能及时处理数据包</li><li>数据到达速度增加会使内存消耗增加</li><li>在大数据包，但是低速的情况下，接收中断会急剧增加，造成效率急剧下降</li></ol></section><h4 id="收包流程"><a class="header-anchor" href="#收包流程"></a>收包流程</h4><section class="reference"><ol><li>网卡到内存<ol><li>数据包从网络进入网卡<ol><li>目标地址是本网卡：跳转到 1.2</li><li>目标地址不是本网卡<ol><li>开启混杂模式：跳转到 1.2</li><li>未开始混杂魔兽：丢弃该网络包</li></ol></li></ol></li><li>网卡将数据包通过 DMA（Direct Memory Access，直接存储器访问）方式写入指定内存地址（该地址由网卡驱动分配并初始化）</li><li>网卡通过 IRQ（硬件中断）通知 CPU</li><li>CPU 根据中断表，调用已注册的中断函数（中断函数会调用驱动中相应的函数）</li><li>驱动先禁用网卡中的中断，再告诉网卡下次接收到数据直接写入内存，不再通知 CPU（避免 CPU 接收大量中断）</li><li>启动软中断</li></ol></li><li>内核网络模块<ol><li>内核中的 ksoftirqd 进程负责处理软中断，当收到软中断后，会调用对应的软中断处理函数（1.6 中抛出的软中断，会调用网络模块的处理函数）</li><li>网络模块中的函数会调用驱动里的轮询函数来一个一个的处理数据包<ol><li>驱动会一个一个的读取网卡写到内存中的数据包</li><li>驱动程序将内存中的数据包转换成内核网络模块能识别的套接字缓存格式</li><li>然后调用 GRO 相关函数，最终将数据放入 CPU 的队列中（如果队列满了，会被丢弃）</li></ol></li><li>CPU 接着处理自己的软中断上下文中的队列里的数据</li><li>待内存中所有数据被处理完后，启用网卡硬中断</li></ol></li></ol></section><h2 id="🌰-socket-程序运行流程"><a class="header-anchor" href="#🌰-socket-程序运行流程"></a>🌰 socket 程序运行流程</h2><section class="reference"><ul><li>在 socket 程序中，程序执行到 recv 函数时， 进程进入「阻塞」状态（被放入内核等待队列，暂停执行后续代码）</li><li>待网卡接收到数据<ul><li>将合适的数据写入指定内存</li><li>触发硬中断并调用驱动里的处理函数，函数禁用网卡硬中断并让网卡下次接收到数据直接写入内存</li><li>启用软中断</li></ul></li><li>内核负责软中断处理的的代码开始执行<ul><li>调用驱动处理内存中的数据</li><li>数据处理完后启用硬中断</li><li>数据被送入协议栈</li></ul></li><li>内核根据数据中的端口信息等得出了数据属于哪个 socket</li><li>再根据 socket fd 得出资源所属进程</li><li>该进程被内核重新放入就「绪队」列等待分配 CPU<ul><li>进程得到 CPU 使用权后，进入「运行」状态，继续处理 recv 后的代码</li></ul></li></ul><p><strong><em>参考链接</em></strong><br><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a><br><a href="https://www.cnblogs.com/xiaomayi-cyj/p/10543027.html" target="_blank" rel="noopener">DPDK（二）：准备知识9 — Linux内核收报流程</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置基础&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前置基础&quot;&gt;&lt;/a&gt;前置基础&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;→ &lt;a href=&quot;/2020/04/22/%E5%9F%BA%E7%A1%80/%
      
    
    </summary>
    
    
      <category term="基础" scheme="http://www.lockey.xyz/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内核" scheme="http://www.lockey.xyz/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="网络数据收发" scheme="http://www.lockey.xyz/tags/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>I/O 多路复用 -- epoll</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-04-22T03:23:54.000Z</published>
    <updated>2020-04-23T03:30:14.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="⚠-基础概念"><a class="header-anchor" href="#⚠-基础概念"></a>⚠️ 基础概念</h2><section class="reference"><p>→ <a href="/2020/04/22/%E5%9F%BA%E7%A1%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD/" title="Linux内核中断">Linux内核中断</a> ←<br>→ <a href="/2020/04/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" title="操作系统基础">操作系统基础</a> ←<br>→ <a href="/2020/04/22/%E5%9F%BA%E7%A1%80/%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B/" title="内核网络数据收发流程">内核网络数据收发流程</a> ←</p></section><h2 id="i-o-多路复用"><a class="header-anchor" href="#i-o-多路复用"></a>I/O 多路复用</h2><section class="reference"><p>I/O 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><div class="warning"><p>通常在 I/O 多路复用中（如 epoll），socket 需要设置为 no-blocking 模式，不然会出现问题 ↓<br>🌰你的「读 fd」需要读取 200 Byte 的数据才会返回，但是发送数据方只发送了 199 Byte，于是你的「读 fd」就一直处于阻塞状态，并最终导致 epoll 处于被阻塞状态？</p></div></section><h2 id="epoll"><a class="header-anchor" href="#epoll"></a>epoll</h2><section class="reference"></section><h4 id="select"><a class="header-anchor" href="#select"></a>select</h4><section class="reference"></section><h5 id="工作流程-开发"><a class="header-anchor" href="#工作流程-开发"></a>工作流程（开发）</h5><section class="reference"><ol><li>准备一个数组，用来存放需要监视的 socket fd</li><li>调用 select</li><li>如果数组中的 socket 都没有数据：进入阻塞状态，直到有 socket 接收到数据，进程被唤醒</li><li>如果有数据则跳转 → 3</li><li>select 返回</li><li>遍历数组中所有 fd：通过 FD_ISSET 判断哪个 scoket 接收到数据</li><li>后续处理</li></ol></section><h5 id="select-缺点"><a class="header-anchor" href="#select-缺点"></a>select 缺点</h5><section class="reference"><ul><li>每次调用 select 都需要将进程加入到所有被监视的 socket 等待队列</li><li>每次唤醒都要把进程从每个队列中移除</li><li>每次都要把 fd 列表传给内核</li><li>开销巨大，监视的 socket 越多，效率越低（所以才会规定默认最大监视数为 1024）</li><li>被唤醒后，由于不知道是哪个 socket 的数据，又需要遍历一次所有 fd</li></ul></section><h4 id="epoll-v2"><a class="header-anchor" href="#epoll-v2"></a>epoll</h4><section class="reference"></section><h5 id="工作流程-开发-v2"><a class="header-anchor" href="#工作流程-开发-v2"></a>工作流程（开发）</h5><section class="reference"><ol><li>用 <code>epoll_create</code> 创建一个 epoll 对象 epfd，并建立了一个「就绪列表」，用来存储就绪的 socket</li><li>再用 <code>epoll_ctl</code> 将所有需要监视的 socket 加入 epfd</li><li>再调用 <code>epoll_wait</code> 阻塞进程，等待数据<ol><li>观察就绪列表有没有数据：有就返回，没有就 sleep，直到 timeout 后返回</li></ol></li><li>处理返回的就绪列表中放入 socket</li></ol></section><h5 id="epoll-对比-selete-的改进"><a class="header-anchor" href="#epoll-对比-selete-的改进"></a>epoll 对比 selete 的改进</h5><section class="reference"><ul><li>分离等待队列和阻塞进程的功能（select 每次都会对 fd 列表进行拷贝，进程频繁加入、移除监视队列等操作）<ul><li>epoll_ctl 维护等待队列<ul><li>内核 eventpoll 会将得到数据的 fd 加入就绪队列，进程不需要遍历所有 fd</li><li>因为不需要遍历所有 fd，而每次就绪的 fd 不会太多，所以等待队列将不需要设置上限</li><li>极大的降低资源浪费</li></ul></li><li>epoll_wait 阻塞进程<ul><li>进程不会因为有 socket 就绪就被频繁唤醒</li></ul></li></ul></li></ul></section><h5 id="epoll-的缺点"><a class="header-anchor" href="#epoll-的缺点"></a>epoll 的缺点</h5><section class="reference"><ul><li>只能在 Linux 平台下使用</li><li>复杂度相对高一点</li><li>在少量并发且 socket 都比较活跃的情况下，epoll 由于其唤醒原理，性能不如 select</li></ul><p><strong><em>参考链接</em></strong><br><a href="https://zhuanlan.zhihu.com/p/64138532" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;⚠-基础概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#⚠-基础概念&quot;&gt;&lt;/a&gt;⚠️ 基础概念&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;→ &lt;a href=&quot;/2020/04/22/%E5%9F%BA%E7%
      
    
    </summary>
    
    
      <category term="术语" scheme="http://www.lockey.xyz/categories/%E6%9C%AF%E8%AF%AD/"/>
    
    
      <category term="I/O多路复用" scheme="http://www.lockey.xyz/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
      <category term="epoll" scheme="http://www.lockey.xyz/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>同步/异步/阻塞/非阻塞、事件驱动、I/O 多路复用</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</id>
    <published>2020-04-22T03:16:56.000Z</published>
    <updated>2020-04-22T03:31:14.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鲁迅说"><a class="header-anchor" href="#鲁迅说"></a>鲁迅说</h2><section class="reference"><p><strong>有异步就有同步，有非阻塞就有阻塞</strong><br>组合可得：同步阻塞、同步不阻塞、异步阻塞、异步不阻塞</p></section><h5 id="一个来自逼乎上的-🌰"><a class="header-anchor" href="#一个来自逼乎上的-🌰"></a>一个来自逼乎上的 🌰 ↓</h5><section class="reference"><blockquote><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><ol><li>老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</li><li>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</li><li>老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</li><li>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。</li></ol><p>所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况 2 中），造成老张效率的低下。<br>所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况 1 和情况 3 中老张就是阻塞的，媳妇喊他都不知道。虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p></blockquote></section><h2 id="什么是-事件驱动-？"><a class="header-anchor" href="#什么是-事件驱动-？"></a>什么是「事件驱动」？</h2><section class="reference"><p>传统编程大部分是线性模式的，控制流程由输入数据和编写的程序决定；在知道这个程序当前的运行状态（包括输入数据和程序本身）的前提下，你就知道接下来甚至一直到结束它的运行流程。</p><p>「事件驱动」是指在持续事务管理过程中，进行决策的一种策略，即跟随当前时间点上出现的事件，调动可用资源，执行相关任务，使不断出现的问题得以解决，防止事务堆积。事件驱动模式比较高冷，有个好莱坞原则：”不要打电话给我们，我们会打电话给你“。事件驱动程序在启动后会处于等待状态，会等待事件触发，然后执行响应函数。又被称为→ <a href="/2020/04/22/%E6%9C%AF%E8%AF%AD/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="I&#x2F;O多路复用">I&#x2F;O多路复用</a> ←……</p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鲁迅说&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#鲁迅说&quot;&gt;&lt;/a&gt;鲁迅说&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;&lt;strong&gt;有异步就有同步，有非阻塞就有阻塞&lt;/strong&gt;&lt;br&gt;
组合可得：同步阻
      
    
    </summary>
    
    
      <category term="术语" scheme="http://www.lockey.xyz/categories/%E6%9C%AF%E8%AF%AD/"/>
    
    
      <category term="同步" scheme="http://www.lockey.xyz/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="异步" scheme="http://www.lockey.xyz/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="阻塞" scheme="http://www.lockey.xyz/tags/%E9%98%BB%E5%A1%9E/"/>
    
      <category term="非阻塞" scheme="http://www.lockey.xyz/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="事件驱动" scheme="http://www.lockey.xyz/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O 多路复用" scheme="http://www.lockey.xyz/tags/I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web 服务的基础概念</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/Web%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E6%9C%AF%E8%AF%AD/Web%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-04-22T02:54:43.000Z</published>
    <updated>2020-04-22T02:56:00.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-服务基础概念"><a class="header-anchor" href="#web-服务基础概念"></a>Web 服务基础概念</h2><section class="reference"><p>如果需要跑起一个普通的 Web 服务（网站、接口服务）， 一般需要有一台主机（云主机等），然后在主机上启动 <strong>Web 应用程序</strong>。</p><p>在 Python 中，大部分 Web 框架（Django、Flask等）自带的 Web 服务器性能较差，不适合在生产环境投入使用，这个问题的解决方案较多，目前使用较多的是使用专业的 <strong>HTTP 服务器（软件，如：Nginx、Apache、IIS等）</strong> 提供 Web 服务，用 <strong>服务器网关接口（WSGI）服务器</strong> 作为 HTTP 服务器和 Web 应用程序或框架之间的接口，构成一个完整的 Web 服务。</p></section><h3 id="什么是-web-应用程序？"><a class="header-anchor" href="#什么是-web-应用程序？"></a>什么是 Web 应用程序？</h3><section class="reference"><p>一个 Web 应用程序是由完成特定任务的各种 Web 组件构成，并通过 Web 将服务展示给外界。在实际应用中，Web 应用程序是由多个 Servlet、JSP 页面、HTML 文件以及图像文件等组成。所有这些组件相互协调为用户提供一组完整的服务。</p></section><h3 id="什么是-http-服务器？"><a class="header-anchor" href="#什么是-http-服务器？"></a>什么是 HTTP 服务器？</h3><section class="reference"><p>HTTP 服务器通常也叫 Web 服务器……（？？？黑人问号脸？？？）<br>它通过 HTTP 协议处理 Web 请求（接收和管理）。</p></section><h3 id="什么是-wsgi-服务器？"><a class="header-anchor" href="#什么是-wsgi-服务器？"></a>什么是 WSGI 服务器？</h3><section class="reference"><p>WSGI（Python Web Server Gateway Interface）基于 CGI（Common Gateway Interface） 标准设计，是为 Python 定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口（其他语言在这之后也出现类似的接口）。WSGI 服务器是基于 WSGI 协议实现的用来调用 Web 应用程序的服务器，另外，它也可以接收来自 HTTP 服务器的实现 WSGI 接口的请求数据，完美对接了 Web 应用程序和 HTTP 服务器的请求、数据交互。</p></section><h2 id="wsgi-的优缺点"><a class="header-anchor" href="#wsgi-的优缺点"></a>WSGI 的优缺点</h2><section class="reference"></section><h4 id="优点"><a class="header-anchor" href="#优点"></a>优点</h4><section class="reference"><ul><li>部署多样化</li><li>组件间高度解耦（任何一个符合 WSGI 规范的应用程序都可以部署在任何一个实现了 WSGI 规范的服务器上）</li></ul></section><h4 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h4><section class="reference"><ul><li>无法处理 WebSocket、HTTP/2 一个 URL 多个请求的模式</li></ul></section><h2 id="继任者-asgi-异步服务器网关接口"><a class="header-anchor" href="#继任者-asgi-异步服务器网关接口"></a>继任者 ASGI（异步服务器网关接口）</h2><section class="reference"><p>ASGI（Asynchronous Server Gateway Interface）是 WSGI 的精神继承者，旨在在具有异步功能的 Python Web 服务器，框架和应用程序之间提供标准接口。</p></section><h2 id="asgi-服务器"><a class="header-anchor" href="#asgi-服务器"></a>ASGI 服务器</h2><section class="reference"></section><h3 id="主流实现"><a class="header-anchor" href="#主流实现"></a>主流实现</h3><section class="reference"><ul><li>Uvicorn</li><li>Daphne</li><li>Hypercorn</li></ul></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-服务基础概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#web-服务基础概念&quot;&gt;&lt;/a&gt;Web 服务基础概念&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;如果需要跑起一个普通的 Web 服务（网站、接口服
      
    
    </summary>
    
    
      <category term="术语" scheme="http://www.lockey.xyz/categories/%E6%9C%AF%E8%AF%AD/"/>
    
    
      <category term="Web" scheme="http://www.lockey.xyz/tags/Web/"/>
    
      <category term="服务" scheme="http://www.lockey.xyz/tags/%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="WSGI" scheme="http://www.lockey.xyz/tags/WSGI/"/>
    
      <category term="ASGI" scheme="http://www.lockey.xyz/tags/ASGI/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核中断初识</title>
    <link href="http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD/"/>
    <id>http://www.lockey.xyz/2020/04/22/%E5%9F%BA%E7%A1%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD/</id>
    <published>2020-04-22T02:52:16.000Z</published>
    <updated>2020-04-23T01:59:45.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核对硬件设备的管理方式"><a class="header-anchor" href="#内核对硬件设备的管理方式"></a>内核对硬件设备的管理方式</h2><section class="reference"><ul><li>轮询：内核定期对设备状态进行查询<ul><li>❎周期性重复执行、浪费资源、效率低下</li></ul></li><li>中断：硬件在需要的时候向内核发出信号<ul><li>✅资源利用率高</li></ul></li></ul></section><h2 id="中断"><a class="header-anchor" href="#中断"></a>中断</h2><section class="reference"></section><h4 id="什么是中断"><a class="header-anchor" href="#什么是中断"></a>什么是中断?</h4><section class="reference"><ul><li>物理学角度说，中断是一种「电信号」</li><li>由硬件设备产生并送入中断控制器的输入引脚上</li><li>中断控制器收到信号，向处理器发送相应信号</li><li>处理器接收到信号，中断当前正在处理的工作，转而去处理中断信号，之后通知 OS 产生中断</li><li>OS 处理中断</li></ul><div class="info"><ol><li>不同设备对应不同中断</li><li>每个中断用一个唯一数字标识（值被称为中断请求线）</li></ol></div></section><h4 id="中断分类"><a class="header-anchor" href="#中断分类"></a>中断分类</h4><section class="reference"><ul><li>同步中断<ul><li>由 CPU 内部电信号产生</li><li>当前指令执行完才会产生中断</li><li>CPU 主动产生，执行点可控</li><li>也称为异常（代码错误产生或 CPU 处理异常条件）</li></ul></li><li>异步中断<ul><li>外设产生</li><li>发生时间点不可预期</li></ul></li></ul><div class="info"><p>通常来说：异步中断被称为中断，为来自 I/O 设备的信号；同步中断分为故障、陷阱、终止。</p></div></section><h4 id="硬中断与软中断"><a class="header-anchor" href="#硬中断与软中断"></a>硬中断与软中断</h4><section class="reference"><ul><li>硬中断：一般就是指的硬件中断，也就是常说的中断，由硬件触发</li><li>软中断：是通信进程之间用来模拟硬中断的一种信号通信方式。是属于一种编程手段，也有称之为软中断通信机制</li></ul><p><strong><em>参考链接</em></strong><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/index.html" target="_blank" rel="noopener">IBM</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内核对硬件设备的管理方式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#内核对硬件设备的管理方式&quot;&gt;&lt;/a&gt;内核对硬件设备的管理方式&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;轮询：内核定期对设备状态进
      
    
    </summary>
    
    
      <category term="基础" scheme="http://www.lockey.xyz/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="中断" scheme="http://www.lockey.xyz/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="内核" scheme="http://www.lockey.xyz/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Uvicorn - 最强异步服务器网关接口？</title>
    <link href="http://www.lockey.xyz/2020/04/20/Python/Uvicorn--%E6%9C%80%E5%BC%BA%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F/"/>
    <id>http://www.lockey.xyz/2020/04/20/Python/Uvicorn--%E6%9C%80%E5%BC%BA%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F/</id>
    <published>2020-04-20T06:47:47.000Z</published>
    <updated>2020-04-23T03:37:07.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a class="header-anchor" href="#前置知识"></a>前置知识</h2><section class="reference"><p>→ <a href="/2020/04/22/%E6%9C%AF%E8%AF%AD/Web%E6%9C%8D%E5%8A%A1/" title="Web服务、ASGI">Web服务、ASGI</a> ←<br>→ <a href="/2020/04/22/%E6%9C%AF%E8%AF%AD/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/" title="异步非阻塞及事件驱动">异步非阻塞及事件驱动</a> ←<br>→ <a href="/2020/04/22/%E6%9C%AF%E8%AF%AD/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="I&#x2F;O多路复用">I&#x2F;O多路复用</a> ←</p></section><h2 id="uvicorn"><a class="header-anchor" href="#uvicorn"></a>Uvicorn</h2><section class="reference"><p><strong><em>The lightning-fast ASGI server.</em></strong><br>基于 uvloop 和 httptools 的 ASGI 实现。</p></section><h3 id="什么是-uvloop？"><a class="header-anchor" href="#什么是-uvloop？"></a>什么是 uvloop？</h3><section class="reference"><ul><li>是一个高性能的异步非阻塞框架</li><li>是完整的 asyncio 事件循环的替代品</li><li>建立在 libuv 之上<ul><li>libuv 是一个高性能的，事件驱动的 I/O 库，并且提供了跨平台（如windows, linux）的 API</li></ul></li><li>由 Cython 编写</li></ul></section><h4 id="什么是-libuv？"><a class="header-anchor" href="#什么是-libuv？"></a>什么是 libuv？</h4><section class="reference"></section><h5 id="libuv-架构图"><a class="header-anchor" href="#libuv-架构图"></a>libuv 架构图 ↓</h5><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="architecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>libuv 提供了不同的接口来操作网络 I/O、文件 I/O、DNS 相关函数以及用户代码</li><li>网络 I/O 的处理，在不同平台下使用不同的异步模型<ul><li>Linux – epoll</li><li>OSX &amp; BSDs – kqueue</li><li>Windows – IOCP</li><li>SunOS – event ports</li></ul></li><li>文件 I/O、DNS 函数及用户代码处理不依赖平台，直接使用线程池处理</li><li>代码由 C 语言实现</li></ul></section><h3 id="什么是-httptools？"><a class="header-anchor" href="#什么是-httptools？"></a>什么是 httptools？</h3><section class="reference"><ul><li>是 NodeJS HTTP 解析的 Python 实现</li><li>由 Cython 编写</li></ul></section><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><section class="reference"><p>号称”最强“的 Uvicorn，是一个基于事件的非阻塞框架，代码由 Cython 实现，对比 Daphne 的 Twisted（Python 实现） 事件驱动，理论上来说，速度确实是在 Daphone 之上的，Cython + 非阻塞 + 事件循环的组合，目前来看，确实是一个最强组合。</p></section><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><section class="reference"><p>「我愿称你为最强」</p><p><strong><em>参考链接</em></strong><br><a href="https://www.iminho.me/wiki/blog-23.html" target="_blank" rel="noopener">IO多路复用原理剖析</a><br><a href="https://scoolor.github.io/2018/11/08/linux-everything-is-file/" target="_blank" rel="noopener">Linux理解-一切皆文件</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;→ &lt;a href=&quot;/2020/04/22/%E6%9C%AF%E8%AF%AD/W
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.lockey.xyz/categories/Python/"/>
    
    
      <category term="Uvicorn" scheme="http://www.lockey.xyz/tags/Uvicorn/"/>
    
      <category term="异步服务器" scheme="http://www.lockey.xyz/tags/%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>K8S metrics-server 搭建/踩坑</title>
    <link href="http://www.lockey.xyz/2020/04/02/DevOps/K8S_metrics-server_%E6%90%AD%E5%BB%BA_%E8%B8%A9%E5%9D%91/"/>
    <id>http://www.lockey.xyz/2020/04/02/DevOps/K8S_metrics-server_%E6%90%AD%E5%BB%BA_%E8%B8%A9%E5%9D%91/</id>
    <published>2020-04-02T03:59:05.000Z</published>
    <updated>2020-04-02T04:06:47.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><section class="reference"></section><h2 id="搭建"><a class="header-anchor" href="#搭建"></a>搭建</h2><section class="reference"><ol><li><a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="noopener">下载</a>配置文件</li><li>修改<code>deploy/kubernetes/metrics-server-deployment.yaml</code> image（国内）</li><li>修改<code>deploy/kubernetes/metrics-server-deployment.yaml</code> args 配置（在出现：<code>no metrics known for pod</code> <code>timeout</code>等错误时修改；应该会有安全隐患，慎用）<ol><li>增加 - --kubelet-insecure-tls  # 不验证TLS</li><li>增加 - --kubelet-preferred-address-types=InternalDNS,InternalIP,ExternalDNS,ExternalIP,Hostname  # 直接访问IP</li></ol></li></ol></section><h2 id="测试"><a class="header-anchor" href="#测试"></a>测试</h2><section class="reference"><p><code>kubectl top node</code><br><code>kubectl top pod</code><br>显示资源信息</p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;&lt;/section&gt;
&lt;h2 id=&quot;搭建&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="metrics-server" scheme="http://www.lockey.xyz/tags/metrics-server/"/>
    
  </entry>
  
  <entry>
    <title>Docker 构建私有 pip 仓库（devpi）</title>
    <link href="http://www.lockey.xyz/2020/04/01/Python/Docker%E6%9E%84%E5%BB%BA%E7%A7%81%E6%9C%89pip%E4%BB%93%E5%BA%93/"/>
    <id>http://www.lockey.xyz/2020/04/01/Python/Docker%E6%9E%84%E5%BB%BA%E7%A7%81%E6%9C%89pip%E4%BB%93%E5%BA%93/</id>
    <published>2020-04-01T06:09:19.000Z</published>
    <updated>2020-04-01T06:22:31.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a class="header-anchor" href="#使用场景"></a>使用场景</h2><section class="reference"><ul><li>网络环境不佳、不允许</li><li>需要经常性的使用pip（比如 docker 镜像构建）</li><li>觉得第三方源的使用，使带宽压力大</li></ul></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="docker-启动-devip-服务"><a class="header-anchor" href="#docker-启动-devip-服务"></a>Docker 启动（devip）服务</h4><section class="sample"><pre><code>docker run -d --name devpi \    --publish 3141:3141 \    --volume /Users/lockey/pypi:/data \  # 自行替换挂载目录    --env=DEVPI_PASSWORD=secret \  # 自行更改登录密码    --restart always \    muccg/devpi:4.5.0</code></pre></section><section class="reference"></section><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><section class="reference"><p><code>pip install devpi</code></p></section><h4 id="设置"><a class="header-anchor" href="#设置"></a>设置</h4><section class="reference"><p><code>devpi use http://10.0.0.38:3141/root/public</code></p></section><h4 id="登录"><a class="header-anchor" href="#登录"></a>登录</h4><section class="reference"><p><code>devpi login root</code></p></section><h4 id="上传"><a class="header-anchor" href="#上传"></a>上传</h4><section class="reference"><ol><li>下载需要上传的 pip 包（whl、gz、zip等）</li><li><code>devpi upload --from-dir --formats=* .</code>  # 自行修改上传目录</li></ol></section><h4 id="使用-v2"><a class="header-anchor" href="#使用-v2"></a>使用</h4><section class="reference"><p><a href="https://developer.aliyun.com/mirror/pypi?spm=a2c6h.13651102.0.0.3e221b11w9yGDx" target="_blank" rel="noopener">同普通第三方源修改步骤</a></p><p><strong><em>参考链接</em></strong><br><a href="https://hub.docker.com/r/muccg/devpi" target="_blank" rel="noopener">DockerHUB</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;网络环境不佳、不允许&lt;/li&gt;
&lt;li&gt;需要经常性的使用pip（比如 do
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.lockey.xyz/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.lockey.xyz/tags/Python/"/>
    
      <category term="pip" scheme="http://www.lockey.xyz/tags/pip/"/>
    
      <category term="devpi" scheme="http://www.lockey.xyz/tags/devpi/"/>
    
      <category term="私有" scheme="http://www.lockey.xyz/tags/%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>在K8S集群中搭建Redis集群(istio网络)</title>
    <link href="http://www.lockey.xyz/2020/03/25/DevOps/%E5%9C%A8K8S%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/"/>
    <id>http://www.lockey.xyz/2020/03/25/DevOps/%E5%9C%A8K8S%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/</id>
    <published>2020-03-25T06:46:50.000Z</published>
    <updated>2020-03-25T07:26:37.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><section class="reference"><ul><li>在 K8S 集群中搭建 Redis 集群</li><li>K8S 集群使用 istio 接管网络</li></ul></section><h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2><section class="reference"><div class="warning"><p>由于 istio 接管网络，会造成 Redis 集群初始化不能成功（一直卡在：Waiting for the cluster to join）<br>以上问题需要在 pod 启动的时候设置 cluster-announce-ip，具体见下 ↓</p></div></section><h2 id="部署集群前提"><a class="header-anchor" href="#部署集群前提"></a>部署集群前提</h2><section class="reference"><ul><li>使用 PV/PVC 存储（<a href="../../Linux/Ubuntu18.04--NFS%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/">可搭建 NFS</a>）</li><li>使用 StatefulSet 配置集群</li><li>确认节点间 6379、16379 端口可访问</li></ul></section><h2 id="部署"><a class="header-anchor" href="#部署"></a>部署</h2><section class="reference"></section><h4 id="部署-nfs-管理-nfs-client-provisioner"><a class="header-anchor" href="#部署-nfs-管理-nfs-client-provisioner"></a>部署 NFS 管理(nfs-client-provisioner)</h4><section class="sample"><pre><code>cat &lt;&lt; EOF &gt; ncp.yaml---kind: ServiceAccountapiVersion: v1metadata:  name: nfs-client-provisioner---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: nfs-client-provisioner-runnerrules:  - apiGroups: [&quot;&quot;]    resources: [&quot;persistentvolumes&quot;]    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]  - apiGroups: [&quot;&quot;]    resources: [&quot;persistentvolumeclaims&quot;]    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]  - apiGroups: [&quot;storage.k8s.io&quot;]    resources: [&quot;storageclasses&quot;]    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]  - apiGroups: [&quot;&quot;]    resources: [&quot;events&quot;]    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]  - apiGroups: [&quot;&quot;]    resources: [&quot;endpoints&quot;]    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: run-nfs-client-provisionersubjects:  - kind: ServiceAccount    name: nfs-client-provisioner    namespace: defaultroleRef:  kind: ClusterRole  name: nfs-client-provisioner-runner  apiGroup: rbac.authorization.k8s.io---kind: DeploymentapiVersion: apps/v1metadata:  name: nfs-client-provisionerspec:  replicas: 1  selector:    matchLabels:      app: nfs-client-provisioner  strategy:    type: Recreate  template:    metadata:      labels:        app: nfs-client-provisioner    spec:      serviceAccountName: nfs-client-provisioner      containers:        - name: nfs-client-provisioner          image: &lt;镜像仓库(网络方便可以自行到 Docker HUB 找镜像、版本)&gt;/nfs-client-provisioner:latest          volumeMounts:            - name: nfs-client-root              mountPath: /persistentvolumes          env:            - name: PROVISIONER_NAME              value: nfs-client-provisioner            - name: NFS_SERVER              value: &lt;NFS 服务端主机 IP&gt;            - name: NFS_PATH              value: &lt;NSF 服务端导出目录&gt;      volumes:        - name: nfs-client-root          nfs:            server: &lt;NFS 服务端主机 IP&gt;            path: &lt;NSF 服务端导出目录&gt;---apiVersion: storage.k8s.io/v1kind: StorageClassmetadata:  name: nfs-storageprovisioner: nfs-client-provisionerEOF</code></pre></section><section class="reference"></section><h4 id="部署-redis-集群"><a class="header-anchor" href="#部署-redis-集群"></a>部署 Redis 集群</h4><section class="sample"><pre><code>cat &lt;&lt; EOF &gt; redis-cluster.yaml---apiVersion: v1kind: ConfigMapmetadata:  name: redis-clusterdata:  update-node.sh: |    #!/bin/sh    REDIS_NODES=&quot;/data/nodes.conf&quot;    sed -i -e &quot;/myself/ s/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/${POD_IP}/&quot; ${REDIS_NODES}    cp /conf/redis.conf /redis.conf    sed -i &quot;s/MY_IP/${POD_IP}/&quot; /redis.conf  # 解决 istio 网络下，Redis 集群初始化失败问题    exec &quot;$@&quot;  redis.conf: |+    cluster-enabled yes    cluster-require-full-coverage no    cluster-node-timeout 15000    cluster-config-file /data/nodes.conf    cluster-migration-barrier 1    appendonly yes    protected-mode no    cluster-announce-ip MY_IP  # 解决 istio 网络下，Redis 集群初始化失败问题#创建statefulset服务---apiVersion: apps/v1kind: StatefulSetmetadata:  name: redis-clusterspec:  serviceName: redis-cluster  replicas: 6  selector:    matchLabels:      app: redis-cluster  template:    metadata:      labels:        app: redis-cluster    spec:      containers:      - name: redis        image: &lt;镜像仓库(网络方便可以自行到 Docker HUB 找镜像、版本&gt;/redis:5.0.1-alpine        ports:        - containerPort: 6379          name: client        - containerPort: 16379          name: gossip        command: [&quot;/conf/update-node.sh&quot;, &quot;redis-server&quot;, &quot;/redis.conf&quot;]        env:        - name: POD_IP          valueFrom:            fieldRef:              fieldPath: status.podIP        volumeMounts:        - name: conf          mountPath: /conf          readOnly: false        - name: data          mountPath: /data          readOnly: false      volumes:      - name: conf        configMap:          name: redis-cluster          defaultMode: 0755  volumeClaimTemplates:  # pvc模板  - metadata:      name: data      annotations:        volume.beta.kubernetes.io/storage-class: nfs-storage  # 指定存储类为nfs-storage    spec:      accessModes: [ &quot;ReadWriteOnce&quot; ]      resources:        requests:          storage: 1Gi  # 指定持久卷大小---apiVersion: v1kind: Servicemetadata:  name: redis-clusterspec:  type: ClusterIP  ports:  - port: 6379    targetPort: 6379    name: client  - port: 16379    targetPort: 16379    name: gossip  selector:    app: redis-cluster</code></pre></section><section class="reference"></section><h4 id="初始化集群"><a class="header-anchor" href="#初始化集群"></a>初始化集群</h4><section class="reference"><p>$<code>kubectl exec -it redis-cluster-0 -- redis-cli --cluster create --cluster-replicas 1 $(kubectl get pods -l app=redis-cluster -o jsonpath='{range.items[*]}{.status.podIP}:6379 ')</code></p></section><h2 id="测试"><a class="header-anchor" href="#测试"></a>测试</h2><section class="reference"><p>使用<code>redis-cli -c</code>测试集群命令</p><p><strong><em>参考链接</em></strong><br><a href="https://rancher.com/blog/2019/deploying-redis-cluster/" target="_blank" rel="noopener">Deploying Redis Cluster on Top of Kubernetes</a><br><a href="https://stackoverflow.com/questions/58528831/is-it-possible-to-create-a-redis-cluster-within-kubernetes-using-a-istio-search" target="_blank" rel="noopener">Is it possible to create a Redis Cluster within Kubernetes using a Istio Search Mesh?</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;在 K8S 集群中搭建 Redis 集群&lt;/li&gt;
&lt;li&gt;K8S 集群使用 isti
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="K8S" scheme="http://www.lockey.xyz/tags/K8S/"/>
    
      <category term="istio" scheme="http://www.lockey.xyz/tags/istio/"/>
    
      <category term="Redis" scheme="http://www.lockey.xyz/tags/Redis/"/>
    
      <category term="集群" scheme="http://www.lockey.xyz/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 NFS 安装使用</title>
    <link href="http://www.lockey.xyz/2020/03/25/Linux/Ubuntu18.04--NFS%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.lockey.xyz/2020/03/25/Linux/Ubuntu18.04--NFS%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-25T06:12:31.000Z</published>
    <updated>2020-03-25T06:45:11.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a class="header-anchor" href="#环境"></a>环境</h2><section class="reference"><ul><li>Ubuntu 18.04</li></ul></section><h2 id="安装"><a class="header-anchor" href="#安装"></a>安装</h2><section class="reference"></section><h4 id="安装软件包"><a class="header-anchor" href="#安装软件包"></a>安装软件包</h4><section class="sample"><p>$<code>apt install nfs-kernel-server</code><br>如出现依赖错误 ↓</p><pre><code>...The following packages have unmet dependencies: nfs-kernel-server : Depends: libtirpc1 but it is not going to be installed                     Depends: nfs-common (= 1:1.2.8-6ubuntu1.2) but it is not going to be installedE: Unable to correct problems, you have held broken packages.</code></pre></section><section class="reference"></section><h5 id="错误解决办法："><a class="header-anchor" href="#错误解决办法："></a>错误解决办法：</h5><section class="reference"><ol><li>apt 安装依赖</li><li>第一步如果出现更多依赖报错看第 3 步</li><li>手动安装<ol><li>下载安装包（<a href="http://archive.ubuntu.com/ubuntu/pool/main/libt/libtirpc/libtirpc1_0.2.5-1.2ubuntu0.1_amd64.deb" target="_blank" rel="noopener">libtirpc1_0.2.5-1.2ubuntu0.1_amd64.deb</a>）<a href="http://archive.ubuntu.com/ubuntu/pool/main/n/nfs-utils/nfs-kernel-server_1.3.4-2.1ubuntu5_amd64.deb" target="_blank" rel="noopener">nfs-kernel-server_1.3.4-2.1ubuntu5_amd64.deb</a><a href="http://archive.ubuntu.com/ubuntu/pool/main/n/nfs-utils/nfs-common_1.3.4-2.1ubuntu5_amd64.deb" target="_blank" rel="noopener">nfs-common_1.3.4-2.1ubuntu5_amd64.deb</a><a href="http://archive.ubuntu.com/ubuntu/pool/main/k/keyutils/keyutils_1.5.9-9.2ubuntu2_amd64.deb" target="_blank" rel="noopener">keyutils_1.5.9-9.2ubuntu2_amd64.deb</a></li><li>使用<code>dpkg -i</code>安装下载好的 deb 包；如出现错误提示，可以根据提示使用 apt 或再下载安装包安装</li><li>再有问题可以使用 journalctl 等工具排查问题</li></ol></li></ol></section><h2 id="配置"><a class="header-anchor" href="#配置"></a>配置</h2><section class="reference"><ol><li>创建导出目录（服务端、客户端共享目录）$<code>mkdir -p /xxx/xxxxx</code></li><li>开放权限$<code>chown nobody:nogroup /xxx/xxxxx &amp;&amp; chmod 777 /xxx/xxxxx</code>(权限开放自己控制，全开有风险，需谨慎使用)</li><li>配置导出目录权限$<code>vim /etc/exports</code>(具体规则 exports 里有 example)</li><li>重启 nfs-kernel-server、rpcbind 服务</li></ol></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"><div class="info"><p>客户端主机需要安装 nfs-common 安装方法同上</p></div></section><h4 id="在客户端主机创建挂载目录"><a class="header-anchor" href="#在客户端主机创建挂载目录"></a>在客户端主机创建挂载目录</h4><section class="reference"><p>$<code>mkdir -p /xxx/xxxxx</code></p></section><h4 id="挂载"><a class="header-anchor" href="#挂载"></a>挂载</h4><section class="reference"><p>$<code>mount -t nfs &lt;NFS服务端主机IP&gt;:&lt;NFS服务端主机导出目录&gt; &lt;客户端主机挂载目录&gt;</code></p></section><h2 id="测试"><a class="header-anchor" href="#测试"></a>测试</h2><section class="reference"><ul><li>在客户端挂载目录中操作（创建文件、文件夹等），能在服务端导出目录中同步</li><li>在服务端导出目录中操作（创建文件、文件夹等），能在客户端挂载目录中同步</li></ul></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 18.04&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.lockey.xyz/categories/Linux/"/>
    
    
      <category term="NFS" scheme="http://www.lockey.xyz/tags/NFS/"/>
    
      <category term="nfs-kernel-server" scheme="http://www.lockey.xyz/tags/nfs-kernel-server/"/>
    
      <category term="Depends" scheme="http://www.lockey.xyz/tags/Depends/"/>
    
  </entry>
  
  <entry>
    <title>istio 安装使用</title>
    <link href="http://www.lockey.xyz/2020/03/16/DevOps/istio%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.lockey.xyz/2020/03/16/DevOps/istio%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-16T08:06:48.000Z</published>
    <updated>2020-03-25T06:11:44.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><section class="reference"><p>Istio 是Google、IBM 和Lyft 联合开源的服务网格（Service Mesh）框架，旨在解决大量微服务的发现、连接、管理、监控以及安全等问题。 Istio 对应用是透明的，不需要改动任何服务代码就可以实现透明的服务治理。</p></section><h2 id="官方文档-中英文可切换"><a class="header-anchor" href="#官方文档-中英文可切换"></a>官方文档（中英文可切换）</h2><section class="reference"><p><a href="https://istio.io/zh/docs/" target="_blank" rel="noopener">istio</a></p></section><h2 id="注意"><a class="header-anchor" href="#注意"></a>注意</h2><section class="reference"><div class="info"><p>官方文档实在太全了，没什么好整理的</p></div><ol><li>稍微阅读文档里的“概念部分”</li><li>安装istio<ol><li>推荐使用：istioctl；helm 方式在新版本已经弃用</li><li>istio 默认使用国外镜像仓库，可以自行修改配置文件（install &gt; kubenetes）</li></ol></li><li>安装示例走一遍</li><li>安装任务走一遍</li><li><strong>istio 接管了网络，会对部分第三方服务的网络访问造成影响(如：Redis 集群的初始化等)</strong></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;Istio 是Google、IBM 和Lyft 联合开源的服务网格（Service Mesh）框架
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="K8S" scheme="http://www.lockey.xyz/tags/K8S/"/>
    
      <category term="Kubernetes" scheme="http://www.lockey.xyz/tags/Kubernetes/"/>
    
      <category term="istio" scheme="http://www.lockey.xyz/tags/istio/"/>
    
      <category term="Server Mesh" scheme="http://www.lockey.xyz/tags/Server-Mesh/"/>
    
  </entry>
  
  <entry>
    <title>Docker 开源仓库系统 Harbor 搭建与使用</title>
    <link href="http://www.lockey.xyz/2020/03/12/DevOps/Docker%E5%BC%80%E6%BA%90%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9FHarbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.lockey.xyz/2020/03/12/DevOps/Docker%E5%BC%80%E6%BA%90%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9FHarbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-12T10:21:45.000Z</published>
    <updated>2020-03-25T06:11:11.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><section class="reference"><ul><li>官方<ul><li><a href="https://goharbor.io/" target="_blank" rel="noopener">Harbor</a>是一个开源的容器镜像管理系统，它通过基于角色的访问控制来保护镜像，扫描镜像中的漏洞，并将图像签名为可信的。作为一个CNCF孵化项目，Harbor 为您提供了合规性、性能和互操作性，帮助您跨云原生计算平台(如 Kubernetes 和 Docker )一致而安全地管理镜像。</li></ul></li><li>非官方<ul><li>开源</li><li>企业级容器镜像管理系统</li><li>成熟</li><li>生态健全</li><li>使用的大厂众多</li><li>搭配在集群内部，加速集群创建、升级</li></ul></li></ul></section><h2 id="环境"><a class="header-anchor" href="#环境"></a>环境</h2><section class="reference"><p>操作系统：Linux(Ubuntu18.04)<br>容器管理：Docker + Docker-Compose</p></section><h2 id="安装"><a class="header-anchor" href="#安装"></a>安装</h2><section class="reference"><ol><li><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">下载安装包</a></li><li>解压并进入安装包</li><li>修改<code>harbor.yml</code>配置（hostname、harbor_admin_password等）</li><li>修改<code>docker-compose.yml</code>（如需要修改镜像源等，有条件可以略过）</li><li>使用 docker-compose 启动 Harbor</li></ol></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"><ul><li>命令行操作与 <a href="https://docs.docker.com/get-started/part3/" target="_blank" rel="noopener">DockerHUB</a> 基本一致</li><li>浏览器<ul><li>修改 /etc/hosts 文件，设置目标主机IP和 harbor.yml 中设置的 hostname</li><li>使用默认用户名 admin 和 harbor.yml 中设置的密码登录</li></ul></li></ul></section><h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2><section class="sample"><ul><li>使用私有仓库时：<ul><li>首先需要在 Docker 客户机上登录（$<code>docker login &lt;hostname&gt;</code>）<ul><li>新版本使用 https，如登录不上：<ul><li>修改 daemon.json 增加 insecure registries（见下面示例 ↓）</li><li>重启 docker 服务</li></ul></li></ul></li></ul></li></ul><p><strong><em>Docker daemon.json 增加 insecure registries</em></strong></p><pre><code>vim /etc/docker/daemon.json---{  &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot; : [&quot;&lt;harbor hostname&gt;&quot;]}---systemctl daemon-reloadsystemctl restart docker</code></pre></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;官方
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://goharbor.io/&quot; 
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="Docker" scheme="http://www.lockey.xyz/tags/Docker/"/>
    
      <category term="Harbor" scheme="http://www.lockey.xyz/tags/Harbor/"/>
    
      <category term="容器" scheme="http://www.lockey.xyz/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="仓库" scheme="http://www.lockey.xyz/tags/%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 KVM 安装使用（GUI）</title>
    <link href="http://www.lockey.xyz/2020/03/12/Linux/Ubuntu18.04--KVM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.lockey.xyz/2020/03/12/Linux/Ubuntu18.04--KVM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-12T06:22:05.000Z</published>
    <updated>2020-03-13T08:08:20.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a class="header-anchor" href="#准备"></a>准备</h2><section class="reference"></section><h5 id="检查硬件虚拟化支持"><a class="header-anchor" href="#检查硬件虚拟化支持"></a>检查硬件虚拟化支持</h5><section class="reference"><p>$<code>egrep -c '(vmx|svm)' /proc/cpuinfo</code><br>输出大于0即可</p></section><h5 id="检查硬件加速-kvm-支持"><a class="header-anchor" href="#检查硬件加速-kvm-支持"></a>检查硬件加速 KVM 支持</h5><section class="reference"><p>$<code>apt install cpu-checker</code><br>$<code>kvm-ok</code><br>输出：<code>KVM acceleration can be used</code>即可</p></section><h5 id="桥接模式-可选"><a class="header-anchor" href="#桥接模式-可选"></a>桥接模式(可选)</h5><section class="reference"><p>设置宿主机桥接网络，Netplan 模式下的 NetworkManager 管理方式使用 $<code>nm-connection-editor</code>进行管理</p></section><h2 id="安装-kvm"><a class="header-anchor" href="#安装-kvm"></a>安装 KVM</h2><section class="reference"><p>$<code>apt install -y qemu qemu-kvm libvirt-bin bridge-utils virt-manager</code></p></section><h5 id="启动和开机启动-libvirt-服务"><a class="header-anchor" href="#启动和开机启动-libvirt-服务"></a>启动和开机启动 libvirt 服务</h5><section class="reference"><p>$<code>systemctl start libvirtd</code><br>$<code>systemctl enable libvirtd</code></p></section><h2 id="使用-kvm"><a class="header-anchor" href="#使用-kvm"></a>使用 KVM</h2><section class="reference"><p>可以使用 $<code>virt-manager</code> GUI 界面管理<br>安装完系统，设置设置虚拟机 NIC 信息（在虚拟机信息面板）为：指定共享设备，输入宿主机桥接网络名(如：br0)，选择 virtio 即可</p><div class="warning"><p>博主桥接网络设置静态 IP 没成功，实在不行可以使用 DHCP 自动分发！</p></div></section><h5 id="kvm-常用命令"><a class="header-anchor" href="#kvm-常用命令"></a>KVM 常用命令</h5><section class="reference"><p>命令 | 功能 | 备注<br>—:---:—<br>virsh list | 查看运行虚拟机 | 查看所有可以加<code>--all</code>参数</p></section><h3 id="未完-待续"><a class="header-anchor" href="#未完-待续"></a>未完…待续…</h3><section class="reference"></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;&lt;/section&gt;
&lt;h5 id=&quot;检查硬件虚拟化支持&quot;&gt;&lt;a class=&quot;header-anchor
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.lockey.xyz/categories/Linux/"/>
    
    
      <category term="KVM" scheme="http://www.lockey.xyz/tags/KVM/"/>
    
      <category term="Ubuntu18.04" scheme="http://www.lockey.xyz/tags/Ubuntu18-04/"/>
    
  </entry>
  
  <entry>
    <title>Linux 基础随笔</title>
    <link href="http://www.lockey.xyz/2020/03/12/Linux/Linux%E5%9F%BA%E7%A1%80%E9%9A%8F%E7%AC%94/"/>
    <id>http://www.lockey.xyz/2020/03/12/Linux/Linux%E5%9F%BA%E7%A1%80%E9%9A%8F%E7%AC%94/</id>
    <published>2020-03-12T02:58:56.000Z</published>
    <updated>2020-03-18T04:30:13.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux-与-发行版"><a class="header-anchor" href="#linux-与-发行版"></a>Linux 与 发行版</h2><section class="reference"></section><h2 id="发行版"><a class="header-anchor" href="#发行版"></a>发行版</h2><section class="reference"></section><h3 id="ubuntu"><a class="header-anchor" href="#ubuntu"></a>Ubuntu</h3><section class="reference"></section><h4 id="镜像版本与后缀"><a class="header-anchor" href="#镜像版本与后缀"></a>镜像版本与后缀</h4><section class="reference"></section><h5 id="版本"><a class="header-anchor" href="#版本"></a>版本</h5><section class="reference"><p>版本间具体区别见官网</p><ul><li>更新间隔通常为6个月</li><li>技术支持至少提供18个月；LTS（Long Time Support）Desktop版本至少3年，Server版本至少5年</li><li>版本号通常为  xx.10</li></ul></section><h5 id="desktop"><a class="header-anchor" href="#desktop"></a>Desktop</h5><section class="reference"><p>桌面版：通常指带操作界面的版本（类似 Win 系统和 Mac 系统）</p></section><h5 id="live-server"><a class="header-anchor" href="#live-server"></a>Live-Server</h5><section class="reference"><p>服务器版：通常不包含界面，操作靠命令终端，安装时可以选择性安装额外插件或最小化安装。大部分服务器会选择这种类型的镜像。</p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux-与-发行版&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#linux-与-发行版&quot;&gt;&lt;/a&gt;Linux 与 发行版&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;&lt;/section&gt;
&lt;h2 id=&quot;发行版&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.lockey.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.lockey.xyz/tags/Linux/"/>
    
      <category term="基础" scheme="http://www.lockey.xyz/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>高可用K8S搭建（Ubuntu18.04）</title>
    <link href="http://www.lockey.xyz/2020/03/11/DevOps/%E9%AB%98%E5%8F%AF%E7%94%A8K8S%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.lockey.xyz/2020/03/11/DevOps/%E9%AB%98%E5%8F%AF%E7%94%A8K8S%E6%90%AD%E5%BB%BA/</id>
    <published>2020-03-11T02:53:25.000Z</published>
    <updated>2020-06-01T01:27:45.638Z</updated>
    
    <content type="html"><![CDATA[<div class="warning"><p>本文资料整理自网络，对其中过时部分进行修正！<br>运行环境为：KVM 虚拟机（先根据下文第一部分制作基础镜像，再用基础镜像克隆为各个 master、worker 节点，可以节省时间）<br>适用版本为：<br>操作系统：Ubuntu18.04<br>Kubeadm：GitVersion:&quot;v1.17.3&quot;<br>K8S组件版本如下：<br>kube-apiserver:v1.17.4<br>kube-controller-manager:v1.17.4<br>kube-scheduler:v1.17.4<br>kube-proxy:v1.17.4<br>pause:3.1<br>etcd:3.4.3-0<br>coredns:1.6.5</p></div><h2 id="第一部分-基础镜像准备"><a class="header-anchor" href="#第一部分-基础镜像准备"></a>第一部分----基础镜像准备</h2><section class="reference"></section><h4 id="harbor-安装"><a class="header-anchor" href="#harbor-安装"></a>Harbor 安装</h4><section class="reference"><p>详见</p></section><h4 id="确保节点之中不可以有重复的主机名-mac-地址或-product-uuid"><a class="header-anchor" href="#确保节点之中不可以有重复的主机名-mac-地址或-product-uuid"></a>确保节点之中不可以有重复的主机名、MAC 地址或 product_uuid</h4><section class="reference"></section><h5 id="hostname-修改"><a class="header-anchor" href="#hostname-修改"></a>hostname 修改</h5><section class="reference"><ul><li>Ubuntu：<code>hostnamectl set-hostname xxx</code></li></ul></section><h5 id="查看-product-uuid"><a class="header-anchor" href="#查看-product-uuid"></a>查看 product_uuid</h5><section class="reference"><p><code>sudo cat /sys/class/dmi/id/product_uuid</code></p></section><h4 id="关闭防火墙-生产环境不建议关闭"><a class="header-anchor" href="#关闭防火墙-生产环境不建议关闭"></a>关闭防火墙（生产环境不建议关闭）</h4><section class="sample"><pre><code>systemctl stop ufwsystemctl disable ufw</code></pre></section><section class="reference"><div class="warning"><p>生产环境，建议启用防火墙，并开启 etcd、apiserver等多个端口</p></div></section><h4 id="关闭-swap"><a class="header-anchor" href="#关闭-swap"></a>关闭 swap</h4><section class="reference"><p>查看 swap：$<code>cat /proc/swaps</code><br>注释 swap 设置：$<code>vim /etc/fstab</code><br>关闭 swap：$<code>swapoff -a</code></p></section><h4 id="禁用-grub-ipv6"><a class="header-anchor" href="#禁用-grub-ipv6"></a>禁用 GRUB ipv6</h4><section class="sample"><p>编辑：$<code>vim /etc/default/grub</code><br>修改：</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;GRUB_CMDLINE_LINUX=&quot;&quot;</code></pre></section><section class="reference"><p>↓</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;ipv6.disable=1&quot;GRUB_CMDLINE_LINUX=&quot;ipv6.disable=1&quot;</code></pre><p>更新：$<code>update-grub</code></p></section><h4 id="设置对应时区-如上海"><a class="header-anchor" href="#设置对应时区-如上海"></a>设置对应时区（如上海）</h4><section class="reference"><p>执行：$<code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></section><h4 id="设置-dns"><a class="header-anchor" href="#设置-dns"></a>设置 DNS</h4><section class="sample"><p>编辑：$<code>vim /etc/systemd/resolved.conf</code><br>修改：</p><pre><code># 地址来自阿里 DNSDNS=223.5.5.5 223.6.6.6 </code></pre></section><section class="reference"></section><h4 id="升级操作系统内核"><a class="header-anchor" href="#升级操作系统内核"></a>升级操作系统内核</h4><section class="reference"><p>参考自<a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/#%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">青木のJava小屋</a></p><p>查看本机内核：$<code>uname -a</code></p><div class="info"><p>可以根据实际情况<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">选择版本</a></p></div><p>执行：$<code>dpkg -i xxx.deb</code>升级内核（可使用通配符）</p><p>清理旧内核：$<code>dpkg --list | grep linux | awk '{print $2}' | grep 旧内核版本 | xargs apt purge -y</code></p><div class="warning"><p>内核操作风险较大，请一步步确认没问题再执行！</p></div></section><h4 id="启用-ipvs-内核模块"><a class="header-anchor" href="#启用-ipvs-内核模块"></a>启用 IPVS 内核模块</h4><section class="sample"><p>执行：</p><pre><code>echo &gt; /etc/modules-load.d/ipvs.confmodule=(ip_vs        ip_vs_rr        ip_vs_wrr        ip_vs_sh        ip_vs_lc        br_netfilter        nf_conntrack)for kernel_module in ${module[@]};do    /sbin/modinfo -F filename $kernel_module |&amp; grep -qv ERROR &amp;&amp; echo $kernel_module &gt;&gt; /etc/modules-load.d/ipvs.conf || :done</code></pre></section><section class="reference"><p>查看：$<code>lsmod | grep ip_vs</code><br>输出如下信息为成功 ↓</p><pre><code>ip_vs_sh               16384  0ip_vs_wrr              16384  0ip_vs_rr               16384  0ip_vs                 147456  6 ip_vs_rr,ip_vs_sh,ip_vs_wrrnf_conntrack          143360  6 xt_conntrack,nf_nat,ipt_MASQUERADE,nf_nat_ipv4,nf_conntrack_netlink,ip_vslibcrc32c              16384  5 nf_conntrack,nf_nat,btrfs,raid456,ip_vs</code></pre></section><h4 id="内核参数调整"><a class="header-anchor" href="#内核参数调整"></a>内核参数调整</h4><section class="sample"><pre><code>cat &gt; /etc/sysctl.conf &lt;&lt; EOF# https://github.com/moby/moby/issues/31208 # ipvsadm -l --timout# 修复ipvs模式下长连接timeout问题 小于900即可net.ipv4.tcp_keepalive_time = 800net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.bridge.bridge-nf-call-arptables = 1vm.swappiness = 0vm.max_map_count=262144EOF</code></pre></section><section class="reference"></section><h4 id="确保-iptables-工具不使用-nftables-后端"><a class="header-anchor" href="#确保-iptables-工具不使用-nftables-后端"></a>确保 iptables 工具不使用 nftables 后端</h4><section class="reference"></section><h5 id="切换旧版-ubuntu"><a class="header-anchor" href="#切换旧版-ubuntu"></a>切换旧版（Ubuntu）</h5><section class="sample"><pre><code>update-alternatives --set iptables /usr/sbin/iptables-legacyupdate-alternatives --set ip6tables /usr/sbin/ip6tables-legacyupdate-alternatives --set arptables /usr/sbin/arptables-legacyupdate-alternatives --set ebtables /usr/sbin/ebtables-legacy</code></pre></section><section class="reference"></section><h4 id="docker-ce-安装"><a class="header-anchor" href="#docker-ce-安装"></a>docker-ce 安装</h4><section class="reference"><p>安装依赖系统工具：$<code>apt install -y apt-transport-https ca-certificates curl software-properties-common</code><br>安装GPG证书：$<code>curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code><br>写入源：$<code>add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code><br>执行：$<code>apt update</code><br>安装 docker-ce：$<code>apt install -y docker-ce</code>（另可指定版本号安装指定版本）<br>设置镜像加速，可以选择阿里云镜像加速服务，详见阿里云镜像加速页面文档</p></section><h4 id="docker-compose-安装"><a class="header-anchor" href="#docker-compose-安装"></a>docker-compose 安装</h4><section class="sample"><p>执行：</p><pre><code>curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre></section><section class="reference"></section><h4 id="kubeadm-套件安装-国内"><a class="header-anchor" href="#kubeadm-套件安装-国内"></a>Kubeadm 套件安装（国内）</h4><section class="reference"><p>新增源文件：$<code>vim /etc/apt/sources.list.d/kubernetes.list</code><br>写入源：$<code>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</code><br>执行：$<code>apt update</code> 得到错误信息的 key 的末尾8位<br>执行：$<code>gpg --keyserver keyserver.ubuntu.com --recv-keys 【8位key】</code><br>执行：$<code>gpg --export --armor 【8位key】 | sudo apt-key add -</code><br>再次执行：$<code>apt update</code><br>安装 Kubeadm 套件：$<code>apt install -y kubelet kubeadm kubectl</code></p></section><h2 id="第二部分-高可用集群搭建"><a class="header-anchor" href="#第二部分-高可用集群搭建"></a>第二部分----高可用集群搭建</h2><section class="reference"><div class="info"><p>本文高可用模式为：ETCD 高可用 + API-Server 高可用<br>ETCD：由于 ETCD 使用 Raft 算法，所以节点一般为奇数个，本文使用3个节点<br>API-Server：本文使用3个节点</p></div></section><h4 id="nginx-本地代理"><a class="header-anchor" href="#nginx-本地代理"></a>Nginx 本地代理</h4><section class="reference"><p>用于访问 master 节点，并在其中某些 master 节点不可用时，自动访问可用节点。<br>可以部署在每一台 K8S 节点上部署，也可另外部署外部 Nginx 负载均衡节点，本文在每台 K8S 节点上均有部署</p></section><h5 id="配置-master-节点-hosts"><a class="header-anchor" href="#配置-master-节点-hosts"></a>配置 master 节点 hosts</h5><section class="sample"><pre><code>cat &gt;&gt; /etc/hosts &lt;&lt; EOF127.0.0.1 server.k8s.local10.0.0.65 server1.k8s.local10.0.0.66 server2.k8s.local10.0.0.67 server3.k8s.localEOF</code></pre></section><section class="reference"><div class="warning"><p>IP 请跟请根据实际情况替换</p></div></section><h5 id="编写-nginx-配置文件"><a class="header-anchor" href="#编写-nginx-配置文件"></a>编写 Nginx 配置文件</h5><section class="sample"><pre><code>mkdir -p /etc/nginxcat &gt; /etc/nginx/nginx.conf &lt;&lt; EOFworker_processes auto;user root;events {    worker_connections  20240;    use epoll;}error_log /var/log/nginx_error.log info;stream {    upstream kube-servers {        hash $remote_addr consistent;        server server1.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;        server server2.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;        server server3.k8s.local:6443 weight=5 max_fails=1 fail_timeout=3s;    }    server {        listen 8443 reuseport;        proxy_connect_timeout 3s;        # 加大timeout        proxy_timeout 3000s;        proxy_pass kube-servers;    }}EOF</code></pre></section><section class="reference"></section><h5 id="启动-nginx"><a class="header-anchor" href="#启动-nginx"></a>启动 Nginx</h5><section class="sample"><pre><code>docker run --restart=always \-v /etc/apt/sources.list:/etc/apt/sources.list \-v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf \--name kps \--net host \-it \-d \nginx</code></pre></section><section class="reference"></section><h4 id="高可用外部-etcd-集群搭建"><a class="header-anchor" href="#高可用外部-etcd-集群搭建"></a>高可用外部 ETCD 集群搭建</h4><section class="sample"><div class="info"><p>由于 etcd 不需要对外开放，所以本文不使用 tls</p></div><div class="warning"><p>启动参数<a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">注意事项</a>：<br>–auto-compaction-retention<br>由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入;所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次;推荐一小时压缩一次数据这样可以极大的保证集群稳定，减少内存和磁盘占用</p><p>–max-request-bytes<br>etcd Raft消息最大字节数，ETCD默认该值为1.5M; 但是很多业务场景发现同步数据的时候1.5M完全没法满足要求，所以提前确定初始值很重要;由于1.5M导致我们线上的业务无法写入元数据的问题，我们紧急升级之后把该值修改为默认32M，但是官方推荐的是10M，大家可以根据业务情况自己调整</p><p>–quota-backend-bytes<br>ETCD db数据大小，默认是2G，当数据达到2G的时候就不允许写入，必须对历史数据进行压缩才能继续写入;参加1里面说的，我们启动的时候就应该提前确定大小，官方推荐是8G，这里我们也使用8G的配置</p></div><p>在 etcd 集群个节点主机上运行如下命令（注意修改中括号内对应的信息）：</p><pre><code>mkdir -p /var/etcddocker rm [name] -frm -rf /var/etcd/*docker run --restart=always --net host -it --name [name] -d \-v /var/etcd:/var/etcd \-v /etc/localtime:/etc/localtime \[仓库名]/etcd:[版本号] \etcd --name [etcd name] \--auto-compaction-retention &quot;1h&quot; --max-request-bytes &quot;33554432&quot; --quota-backend-bytes &quot;8589934592&quot; \--data-dir=/var/etcd/etcd-data \--listen-client-urls http://0.0.0.0:2379 \--listen-peer-urls http://0.0.0.0:2380 \--initial-advertise-peer-urls http://[本节点域名或IP]:2380 \--advertise-client-urls http://[本节点域名或IP]:2379,http://[本节点域名或IP]:2380 \-initial-cluster-token etcd-cluster \-initial-cluster &quot;[本机 etcd name]=http://[本节点域名或IP]:2380,[其他etcd name1]=http://[其他节点域名或IP]:2380,[其他etcd name2]=http://[其他节点域名或IP]:2380&quot; \-initial-cluster-state new</code></pre></section><section class="reference"></section><h5 id="测试-etcd-集群"><a class="header-anchor" href="#测试-etcd-集群"></a>测试 etcd 集群</h5><section class="sample"><p>进入正在运行的 etcd 容器：$<code>docker exec -it [name] sh</code><br>查看集群状态：$<code>etcdctl --write-out=table --endpoints=&quot;http://[节点域名或IP]:2379,http://[节点域名或IP]:2379,http://[节点域名或IP]:2379&quot; endpoint status</code><br>查看集群健康：$<code>etcdctl --write-out=table --endpoints=&quot;http://[节点域名或IP]:2379,http://[节点域名或IP]:2379,http://[节点域名或IP]:2379&quot; endpoint health</code></p><p>测试集群可用性：</p><pre><code># 任意节点存入数据etcdctl put /test/key &quot;123&quot;# 任意节点取出数据，取出正常，集群可用etcdctl get /test/key</code></pre></section><section class="reference"></section><h4 id="api-server-master-高可用"><a class="header-anchor" href="#api-server-master-高可用"></a>API-Server（Master） 高可用</h4><section class="reference"></section><h5 id="配置自定义-kubeadm-config-yaml"><a class="header-anchor" href="#配置自定义-kubeadm-config-yaml"></a>配置自定义 kubeadm-config.yaml</h5><section class="sample"><div class="warning"><p>注意修改对应的版本号，仓库路径等</p></div><pre><code>apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.17.0imageRepository: [仓库路径]apiServer:  extraArgs:    storage-backend: etcd3  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtime  certSANs:    - &quot;prod-server.k8s.local&quot;    - &quot;server1.k8s.local&quot;    - &quot;server2.k8s.local&quot;    - &quot;server3.k8s.local&quot;    - &quot;127.0.0.1&quot;    - &quot;10.0.0.65&quot;    - &quot;10.0.0.66&quot;    - &quot;10.0.0.67&quot;    - &quot;kubernetes&quot;    - &quot;kubernetes.default&quot;    - &quot;kubernetes.default.svc&quot;    - &quot;kubernetes.default.svc.cluster&quot;    - &quot;kubernetes.default.svc.cluster.local&quot;controllerManager:  extraArgs:    experimental-cluster-signing-duration: 867000h  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtimescheduler:  extraVolumes:    - hostPath: /etc/localtime      mountPath: /etc/localtime      name: localtimenetworking:  # pod 网段  podSubnet: 172.224.0.0/12  # SVC 网络  serviceSubnet: 10.96.0.0/12controlPlaneEndpoint: server.k8s.local:8443etcd:  external:    endpoints:      - http://server1.k8s.local:2379      - http://server2.k8s.local:2379      - http://server3.k8s.local:2379---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationmode: ipvsipvs:  scheduler: lc  minSyncPeriod: 5s  syncPeriod: 15s</code></pre></section><section class="reference"></section><h5 id="初始化-master"><a class="header-anchor" href="#初始化-master"></a>初始化 Master</h5><section class="reference"><p>执行：$<code>kubeadm init --config=kubeadm-config.yaml --upload-certs</code></p><div class="info"><p>–config=kubeadm-config.yaml 为上一步骤编写的文件<br>–upload-certs 参数将证书上传到 etcd 中，后续不需要手动分发</p></div><p>初始化结束，控制台输出：<br>Your Kubernetes control-plane has initialized successfully!</p><p>To start using your cluster, you need to run the following as a regular user:<br><strong><em>复制并执行下列命令：可以以普通用户操作集群</em></strong><br><font color=red>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config</font></p><p>You should now deploy a pod network to the cluster.<br>Run “kubectl apply -f [podnetwork].yaml” with one of the options listed at:<br><a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p><p>You can now join any number of the control-plane node running the following command on each as root:<br><strong><em>复制并执行下列命令：其余 master 可以加入到到该集群</em></strong><br><font color=green>kubeadm join server.k8s.local:8443 --token uue99t.w9cenfznjoo2e1u6 <br>–discovery-token-ca-cert-hash sha256:afd406ce180ce4c9271c0e7b4c3381df72cd75e766f934fd439d101ae1022a43 <br>–control-plane --certificate-key 1621bb7101d2fa4050779aaa753e89d49ee7db57129b6b4986c82b45fb4dcbe5</font    ></p><p>Please note that the certificate-key gives access to cluster sensitive data, keep it secret!<br>As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use<br>&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</p><p>Then you can join any number of worker nodes by running the following on each as root:<br><strong><em>复制并执行下列命令：worker 可以加入到到该集群</em></strong><br><font color=blue>kubeadm join server.k8s.local:8443 --token uue99t.w9cenfznjoo2e1u6 <br>–discovery-token-ca-cert-hash sha256:afd406ce180ce4c9271c0e7b4c3381df72cd75e766f934fd439d101ae1022a43<font></p><div class="warning"><p>以上命令中出现的 hash、key 需要跟使用者安装后出现的一致，不可直接复制使用！<br>Token 失效(24小时)可以使用命令重新生成 ↓<br><code>kubeadm token create --print-join-command</code></p><p>Master（–control-plane --certificate-key）（2小时失效）↓<br><code>kubeadm init phase upload-certs --upload-certs --config kubeadm-config.yaml</code></p></div></section><h5 id="master-测试"><a class="header-anchor" href="#master-测试"></a>master 测试</h5><section class="reference"><p>执行：$<code>kubectl get node</code> 可以查看集群是否加入成功（可以显示加入集群内的所有节点）<br>执行：$<code>kubectl get pod -A</code> 可以查看所有集群内正在运行的pod（检查 apiserver、controller-manager、proxy、scheduler 是否是 running 状态，coredns 目前为 pending 状态）</p></section><h4 id="结束"><a class="header-anchor" href="#结束"></a>结束</h4><section class="reference"><p>至此，高可用 K8S 安装成功。</p></section><h4 id="甜点"><a class="header-anchor" href="#甜点"></a>甜点</h4><section class="reference"><p>集群重置：$<code>kubeadm reset</code></p><div class="info"><p>如果是外接 ETCD ，需要清空外接 ETCD 数据：$<code>etcdctl del &quot;&quot; --prefix</code></p></div><p><strong><em>参考链接</em></strong><br><a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/" target="_blank" rel="noopener">在阿里云的VPC部署高可用kubernetes</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;warning&quot;&gt;
&lt;p&gt;本文资料整理自网络，对其中过时部分进行修正！&lt;br&gt;
运行环境为：KVM 虚拟机（先根据下文第一部分制作基础镜像，再用基础镜像克隆为各个 master、worker 节点，可以节省时间）&lt;br&gt;
适用版本为：&lt;br&gt;
操作系统：U
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="K8S" scheme="http://www.lockey.xyz/tags/K8S/"/>
    
      <category term="Kubernetes" scheme="http://www.lockey.xyz/tags/Kubernetes/"/>
    
      <category term="编排" scheme="http://www.lockey.xyz/tags/%E7%BC%96%E6%8E%92/"/>
    
      <category term="高可用" scheme="http://www.lockey.xyz/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>K8S</title>
    <link href="http://www.lockey.xyz/2019/12/31/DevOps/K8S/"/>
    <id>http://www.lockey.xyz/2019/12/31/DevOps/K8S/</id>
    <published>2019-12-31T06:33:19.000Z</published>
    <updated>2020-06-19T01:58:20.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="部署的演化历史"><a class="header-anchor" href="#部署的演化历史"></a>部署的演化历史</h2><section class="reference"><ul><li>传统部署<ul><li>资源分配问题</li></ul></li><li>虚拟化部署<ul><li>量级较重</li></ul></li><li>容器化部署<ul><li>敏捷应用程序的创建和部署</li><li>持续开发、集成和部署方便</li><li>开发运维分离</li><li>可观察性丰富</li><li>跨开发、测试和生产环境一致</li><li>云和操作系统分发的可移植性强</li><li>以应用程序为中心管理</li><li>适合松散耦合、分布式、弹性、解放的微服务</li><li>资源隔离</li><li>资源利用率高</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="部署演进历史.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="容器部署时代面临的问题"><a class="header-anchor" href="#容器部署时代面临的问题"></a>容器部署时代面临的问题</h2><section class="reference"></section><h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5><section class="reference"><ul><li>服务集群越来越大</li><li>传统的集群容器部署方式较繁琐</li><li>工作量日益加大</li><li>容易出错</li></ul></section><h5 id="解决方向"><a class="header-anchor" href="#解决方向"></a>解决方向</h5><section class="reference"><p>需要一个强大的容器管理、编排系统</p></section><h5 id="解决方案"><a class="header-anchor" href="#解决方案"></a>解决方案</h5><section class="reference"><p>kubernetes[K8S]</p></section><h2 id="k8s是什么？"><a class="header-anchor" href="#k8s是什么？"></a>K8S是什么？</h2><section class="reference"></section><h5 id="特点"><a class="header-anchor" href="#特点"></a>特点</h5><section class="reference"><ul><li>可移植</li><li>可扩展</li><li>开源</li><li>生态系统庞大且有活力</li></ul></section><h5 id="作用"><a class="header-anchor" href="#作用"></a>作用</h5><section class="reference"><ul><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自动二进制打包</li><li>自我修复</li><li>秘钥与配置管理</li></ul></section><h5 id="其它意义"><a class="header-anchor" href="#其它意义"></a>其它意义</h5><section class="reference"><ul><li>促进声明式配置</li><li>自动化</li></ul></section><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="k8s架构图.png" alt="架构图" title="">                </div>                <div class="image-caption">架构图</div>            </figure></section><h2 id="组件"><a class="header-anchor" href="#组件"></a>组件</h2><section class="reference"><ul><li>Master【集群控制平面】<ul><li>kube-apiservice<ul><li>主节点上负责提供 Kubernetes API 服务的组件</li><li>支持<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/" target="_blank" rel="noopener">水平扩缩</a></li></ul></li><li><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/docs.md" target="_blank" rel="noopener">etcd</a><ul><li>作为保存 Kubernetes 所有集群数据的后台数据库</li><li>兼具一致性和高可用性的键值数据库</li><li>通常需要有个备份计划</li></ul></li><li>kube-scheduler<ul><li>监视新创建的未指定运行节点的 Pod</li><li>选择节点让 Pod 在上面运行</li></ul></li><li>kube-controller-manager<ul><li>Node Controller<ul><li>负责在节点故障时进行通知和响应</li></ul></li><li>Replication Controller（RC）<ul><li>负责为系统中每个副本控制器对象维护正确数量的 Pod</li></ul></li><li>Endpoints Controller<ul><li>填充端点（Endpoints）对象（即加入 Service 与 Pod）</li></ul></li><li>Service Account &amp; Token Controllers<ul><li>为新的命名空间创建默认账户和 API 访问令牌</li></ul></li></ul></li><li>cloud-controller-manager<ul><li>运行与基础云提供商交互的控制器</li></ul></li></ul></li></ul><p><img src="Master.png" alt="Master"></p><ul><li>Node【维护运行的 Pod 并提供 Kubernetes 运行环境】<ul><li>kubelet<ul><li>保证容器都运行在 Pod 中</li><li>接收一组通过各类机制提供给它的 PodSpecs，确保 PodSpecs 中描述的容器处于运行状态且健康</li><li>不会管理不是由 Kubernetes 创建的容器</li></ul></li><li>kube-proxy<ul><li>是集群中每个节点上运行的网络代理，实现 Kubernetes Service 概念的一部分</li><li>维护节点上的网络规则<ul><li>允许从集群内部或外部网络会话与 Pod 进行网络通信</li></ul></li></ul></li><li>容器运行环境（Docker 等）<ul><li>负责运行容器</li></ul></li></ul></li><li><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">Addons</a>【使用 Kubernetes 资源 (DaemonSet, Deployment等) 实现集群功能；命名空间为：kube-system】<ul><li>DNS<ul><li>所有 Kubernetes 集群都应具有 DNS (非强制性要求)</li><li>为 Kubernetes 集群提供 DNS 记录</li><li>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中</li></ul></li><li>Dashboard<ul><li><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">Web UI</a></li><li>使用户可以管理集群中运行的应用程序以及集群本身进行故障排除</li></ul></li><li>容器资源监控<ul><li>将关于容器的一些常见的时间序列度量值保存到一个集群数据库中</li><li>提供用于浏览这些数据的界面</li></ul></li><li>集群层面日志<ul><li>负责将容器的日志保存到一个集中的日志存储中</li><li>提供搜索和浏览接口</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Node.png" alt="Node" title="">                </div>                <div class="image-caption">Node</div>            </figure><p><strong><em>其他组件</em></strong></p><ul><li><a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" target="_blank" rel="noopener">kubectl</a>【操控 Kubernetes 集群】<ul><li>负责管理 Pods 和它们上面的容器，镜像、volumes、etc</li></ul></li></ul></section><h2 id="设计理念"><a class="header-anchor" href="#设计理念"></a>设计理念</h2><section class="reference"><div class="info"><p>核心理念：</p><ol><li>容错性</li><li>扩展性</li></ol></div></section><h5 id="api-设计原则"><a class="header-anchor" href="#api-设计原则"></a>API 设计原则</h5><section class="reference"><ol><li>所有 API 应该是声明式的</li><li>AIP 对象是彼此互补且可组合的</li><li>高层 API 以操作意图为基础设计</li><li>底层 API 根据高层 API 的控制需要设计</li><li>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏机制</li><li>API 操作复杂度与对象数量成正比</li><li>API 对象状态不能依赖于网络连接状态</li><li>尽量避免让操作机制依赖于全局状态</li></ol></section><h5 id="控制机制设计原则"><a class="header-anchor" href="#控制机制设计原则"></a>控制机制设计原则</h5><section class="reference"><ol><li>控制逻辑应该只依赖于当前状态</li><li>假设任何错误的可能，并做容错处理</li><li>尽量避免复杂状态机，控制逻辑不要依赖无法监控的内部状态</li><li>假设任何操作都可能被任何操作对象拒绝，甚至被错误解析</li><li>每个模块都可以在出错后自动恢复</li><li>每个模块都可以在必要的时候优雅的降级服务</li></ol></section><h5 id="核心技术概念"><a class="header-anchor" href="#核心技术概念"></a>核心技术概念</h5><section class="reference"><table><thead><tr><th>术语</th><th>语义</th><th>备注</th></tr></thead><tbody><tr><td>Pod</td><td>集群中部署应用或服务的最小单元，可以包含多个容器</td><td></td></tr><tr><td>副本集（Replica Set，RS）</td><td>新一代 RC，支持更多匹配模式</td><td></td></tr><tr><td>部署（Deployment）</td><td>表示用户对集群的一次更新操作</td><td></td></tr><tr><td>服务（Service）</td><td>客户端要访问的服务就是 Service 对象</td><td>每个 Service 会对应一个集群内部的虚拟 IP，集群内部通过虚拟 IP 访问服务</td></tr><tr><td>任务（Job）</td><td>控制批处理型任务的对象</td><td></td></tr><tr><td>后台支撑服务集（DaemonSet）</td><td>保证每个节点都有此类 Pod 运行</td><td>典型的支持服务有：存储、日志、监控等</td></tr><tr><td>有状态服务集（PetSet）</td><td>每个 Pod 的名字要事先确定，挂载自己独立的存储</td><td>适合 PetSet 的业务：MySQL、PostgreSQL、Zookeeper等</td></tr><tr><td>集群联邦（Federation）</td><td>提供扩区域跨服务商能力</td><td>每个 Federation 有自己的分布式存储、API Server 和 Controller Manager</td></tr><tr><td>存储卷（Volume）</td><td>与 Docker 存储卷类似，不过作用访问是 Pod</td><td></td></tr><tr><td>持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）</td><td>使集群具备存储的逻辑抽象能力</td><td>PV 和 PVC 的关系相当于 Node 和 Pod 的关系</td></tr><tr><td>名称（Names）</td><td>Kubernetes REST API 中的所有对象都由名称和 UID 明确标识；一次只能有一个给定类型的对象具有给定的名称（如果删除对象，则可以创建同名的新对象）</td><td></td></tr><tr><td>UIDs</td><td>系统生成的字符串，唯一标识对象；在集群的整个生命周期中创建的每一个对象都有一个不同的 UID，用来区分类似实体的历史事件</td><td></td></tr><tr><td>命名空间（Namespace）</td><td>Kubernetes 支持多个虚拟集群，依赖于同一物理集群。这些虚拟集群被称为命名空间。</td><td></td></tr><tr><td>标签和选择器（Labels &amp; Selectors）</td><td>标签是附加到 Kubernetes 对象上的键值对，用于指定对用户有意义且相关的对象标识属性，但不直接对核心系统有语义含义</td><td>每个对象都可以定义一组键/值标签，每个键对于给定对象必须唯一</td></tr><tr><td>注解（Annotations）</td><td>可以使用注解为对象附加任意的非标识的元数据</td><td></td></tr><tr><td>字段选择器（Field Selectors）</td><td>允许根据多个或多个资源字段的值筛选 Kubernetes 资源</td><td></td></tr></tbody></table></section><h2 id="kubernetes-对象管理"><a class="header-anchor" href="#kubernetes-对象管理"></a>Kubernetes 对象管理</h2><section class="reference"><div class="warning"><p>应该只使用一种技术来管理 Kubernetes 对象；混合和匹配技术作用于同一对象上将导致未定义行为</p></div><table><thead><tr><th>类型</th><th>使用环境</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>命令式命令</td><td>测试</td><td>1. 命令简单，易学、易记；</br>2. 快速更改集群</td><td>1. 命令不与变更审查流程集成；<br>2. 不提供与更改管理的审核跟踪；<br>3.除了实时内容，命令不提供记录源；<br>4. 不提供用于创建新对象的模板</td></tr><tr><td>命令式对象配置</td><td>生产</td><td>与命令式命令相比：<br>1. 可以存储在源控制系统中，如：Git；<br>2. 可以与流程集成，如：在推送和审计之前检查更新；<br>3.提供用于创建新对象的模板；<br><br>与声明式对象配置相比：<br>1. 配置行为简单易懂；<br>2. 更加成熟</td><td>与命令式命令相比：<br>1. 需要对对象架构有了解；<br>2. 需要些 YAML 文件；<br><br>与声明式对象配置相比：<br>1. 对活动对象的更新必须反映在配置文件中，否则将在下一次替换时丢失；<br>2. 针对文件而不是目录</td></tr><tr><td>声明式对象配置</td><td>生产</td><td>1. 即使未将对活动对象所做的更改未合并回配置文件中，也将保留这些更改；<br>2. 更好的支持对目录进行操作并自动检测每个对象的操作类型（创建、修补、删除）</td><td>1. 配置难于调试并且出现异常时难以理解；<br>2. 使用差异的部分更新会创建复杂的合并和补丁操作</td></tr></tbody></table></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h5 id="安装"><a class="header-anchor" href="#安装"></a>安装</h5><section class="sample"><pre><code>cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial mainEOFapt-get updateapt-get install -y kubelet kubeadm kubectlapt-mark hold kubelet kubeadm kubectl</code></pre></section><section class="reference"><p><strong><em>参考资料</em></strong><br><a href="https://kubernetes.io/zh/docs/concepts/" target="_blank" rel="noopener">K8S(官方)</a><br><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes 中文社区 | 中文文档</a><br><a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">Kubernetes 中文手册</a></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;部署的演化历史&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#部署的演化历史&quot;&gt;&lt;/a&gt;部署的演化历史&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;传统部署
&lt;ul&gt;
&lt;li&gt;资源分配问题&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="K8S" scheme="http://www.lockey.xyz/tags/K8S/"/>
    
      <category term="Kubernetes" scheme="http://www.lockey.xyz/tags/Kubernetes/"/>
    
      <category term="编排" scheme="http://www.lockey.xyz/tags/%E7%BC%96%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>ELK</title>
    <link href="http://www.lockey.xyz/2019/12/20/DevOps/ELK/"/>
    <id>http://www.lockey.xyz/2019/12/20/DevOps/ELK/</id>
    <published>2019-12-20T02:00:31.000Z</published>
    <updated>2019-12-26T02:00:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elk-是什么"><a class="header-anchor" href="#elk-是什么"></a>ELK 是什么?</h2><section class="reference"><ul><li>是 ElasticSearch、Logstash、Kibana 三个开源软件的组合</li><li>具备数据收集、存储、分析功能</li><li>适合实时数据分析和检索的场景</li><li>具有分布式特性</li><li>易扩展</li></ul></section><h2 id="elk-功能"><a class="header-anchor" href="#elk-功能"></a>ELK 功能</h2><section class="reference"><ul><li>ElasticSearch<ul><li>存储</li><li>索引</li></ul></li><li>Logstash<ul><li>收集</li><li>处理</li></ul></li><li>Kibana<ul><li>可视化</li><li>统计分析</li></ul></li><li>Beat（扩展组件）<ul><li>MetricBeat<ul><li>收集各种主机信息（CPU、内存……），详见官网</li></ul></li><li>Filebeat<ul><li>轻量级日志收集组件</li></ul></li></ul></li></ul></section><h2 id="简单架构"><a class="header-anchor" href="#简单架构"></a>简单架构</h2><section class="reference"><div id="flowchart-0" class="flow-chart"></div></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="使用-docker-安装-elk"><a class="header-anchor" href="#使用-docker-安装-elk"></a>使用 Docker 安装 ELK</h4><section class="reference"><p>参考 <a href="https://github.com/deviantony/docker-elk.git" target="_blank" rel="noopener">https://github.com/deviantony/docker-elk.git</a></p><div class="info"><ul><li>Kibana 中文设置<br><code>$ vim kibana/config/kibana.yml</code></li><li>新增中文配置 ↓↓↓</li><li>i18n.locale: “zh-CN”</li></ul></div><div class="warning"><ul><li>ElasticSearch 默认需要 4G 内存；可以通过设置 ES_JAVA_OPTS 来修改</li><li>如：<code>ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot;</code></li></ul></div></section><h4 id="使用-docker-安装-metricbeat"><a class="header-anchor" href="#使用-docker-安装-metricbeat"></a>使用 Docker 安装 MetricBeat</h4><section class="sample"><p><strong><em>获取配置文件</em></strong></p><ul><li>下载 <code>$ wget https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-7.4.1-linux-x86_64.tar.gz</code></li><li>解压 <code>$ tar zxvf metricbeat-7.4.1-linux-x86_64.tar.gz</code></li><li>提取 <code>metricbeat.yml modules.d</code></li></ul><p><strong><em>使用 Docker Compose</em></strong><br><code>$ vim docker-compose.yml</code></p><pre><code class="language-yml">version: '2'services:  metricbeat:    image: docker.elastic.co/beats/metricbeat:7.4.1    container_name: metricbeat    volumes:      - /var/run/docker.sock:/var/run/docker.sock:ro      - /proc:/hostfs/proc:ro      - /sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro      - /:/hostfs:ro      - ./metricbeat/metricbeat.yml:/usr/share/metricbeat/metricbeat.yml:ro      - ./metricbeat/modules.d:/usr/share/metricbeat/modules.d:ro      -  /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro    user: &quot;root&quot;    command: -system.hostfs=/hostfs -e    restart: always</code></pre></section><section class="reference"><p><code>docker exec -it metricbeat metricbeat modules enable system</code><script src="https://cdn.bootcss.com/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.12.2/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op0=>operation: Data（Log）op1=>operation: MetricBeatop2=>operation: Redisop3=>operation: Logstashop4=>operation: ElasticSearchop5=>operation: Kibanaop0(right)->op2op1(right)->op4op2(right)->op3op3(right)->op4op4(right)->op5</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;elk-是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#elk-是什么&quot;&gt;&lt;/a&gt;ELK 是什么?&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;ul&gt;
&lt;li&gt;是 ElasticSearch、Logstash、Ki
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="ELK" scheme="http://www.lockey.xyz/tags/ELK/"/>
    
      <category term="ElasticSearch" scheme="http://www.lockey.xyz/tags/ElasticSearch/"/>
    
      <category term="Logstash" scheme="http://www.lockey.xyz/tags/Logstash/"/>
    
      <category term="Kibana" scheme="http://www.lockey.xyz/tags/Kibana/"/>
    
      <category term="MetricBeat" scheme="http://www.lockey.xyz/tags/MetricBeat/"/>
    
      <category term="日志" scheme="http://www.lockey.xyz/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix</title>
    <link href="http://www.lockey.xyz/2019/12/13/DevOps/Zabbix/"/>
    <id>http://www.lockey.xyz/2019/12/13/DevOps/Zabbix/</id>
    <published>2019-12-13T07:07:21.000Z</published>
    <updated>2020-06-19T01:57:52.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-zabbix-？"><a class="header-anchor" href="#什么是-zabbix-？"></a>什么是 Zabbix ？</h2><section class="reference"><p>Zabbix 是一种系统监控。网络监控、服务监控工具。</p></section><h4 id="监控对象"><a class="header-anchor" href="#监控对象"></a>监控对象</h4><section class="reference"><ul><li>主机</li><li>软件</li></ul></section><h4 id="模块功能"><a class="header-anchor" href="#模块功能"></a>模块功能</h4><section class="reference"><ul><li>Monitoring<ul><li>信息聚合</li><li>状态展示</li><li>信息查询</li><li>监控统计</li></ul></li><li>Inventory<ul><li>资产信息<ul><li>管理</li><li>查询</li></ul></li></ul></li><li>Report<ul><li>报表</li><li>审计</li><li>日志</li></ul></li><li>Configuration<ul><li>主机信息配置</li><li>监控规则配置</li><li>报警规则配置</li><li>统计图表配置</li><li>自动发现配置</li></ul></li><li>Administrator<ul><li>用户权限管理</li><li>报警方式配置</li><li>脚本配置</li><li>代理配置</li></ul></li><li>Personal<ul><li>接收报警配置</li><li>接收报警规则</li><li>个人信息管理</li></ul></li></ul></section><h2 id="zabbix-特点"><a class="header-anchor" href="#zabbix-特点"></a>Zabbix 特点</h2><section class="reference"><ul><li>安装简单</li><li>监控方便</li><li>免费开源</li><li>自动化</li><li>C/S 结构、分布式架构</li></ul></section><h2 id="与同类型比较"><a class="header-anchor" href="#与同类型比较"></a>与同类型比较</h2><section class="reference"><table><thead><tr><th>系统名称</th><th>默认监控</th><th>自定义监控</th><th>批量监控</th><th>修改监控</th><th>图表</th><th>报警</th><th>其他</th></tr></thead><tbody><tr><td>Zabbix</td><td>自带监控多</td><td>可自定义编写插件</td><td>server 端可配置自动注册规则；client 端无需操作</td><td>手动在模板中新增监控</td><td>自带图表插件</td><td>支持多种报警，依赖插件</td><td>自带 Web 监控</td></tr><tr><td>Nagios</td><td>自带监控少</td><td>可自定义编写插件</td><td>用脚本在 server 端新增 host， 并拷贝 service 文件</td><td>用脚本修改所有主机的 service 文件，加入新增服务</td><td>可以按照图表插件</td><td>支持多种报警，依赖插件</td><td></td></tr></tbody></table><hr><div class="info"><ul><li>Zabbix 使用更友好，探索功能需要较多时间，学习成本较大</li><li>Nagios 容易上手，脚本很强大，但写起来也费时费力</li></ul></div></section><h2 id="架构图"><a class="header-anchor" href="#架构图"></a>架构图</h2><section class="reference"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/Zabbix架构.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h4 id="部署方式"><a class="header-anchor" href="#部署方式"></a>部署方式</h4><section class="reference"><ul><li>网络协议模式：server-client</li><li>代理模式：server-proxy-client</li><li>节点模式：master-node-client</li></ul></section><h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2><section class="reference"></section><h4 id="安装"><a class="header-anchor" href="#安装"></a>安装</h4><section class="reference"><ol><li>打开<a href="https://www.zabbix.com/download" target="_blank" rel="noopener">官网下载页面</a></li><li>选择操作系统</li><li>按引导安装<ol><li>安装 Server 端<ol><li>添加源</li><li>安装 Server</li><li>安装 MySQL</li><li>初始化 MySQL</li><li>启动 zabbix-server</li></ol></li><li>安装 Web 端<ol><li>安装 Web</li><li>配置 timezone：<ol><li><code>$ vim /etc/php-fpm.d/zabbix.conf</code></li><li><code>; php_value[date.timezone] = Asian/Shanghai</code></li></ol></li><li>启动 [httpd|nginx|apache2] php-fpm</li><li>打开 <code>http://[ip]/zabbix</code><ol><li>默认用户密码：<code>Admin : zabbix</code></li></ol></li></ol></li><li>安装 Agent 端<ol><li>添加源</li><li>安装 Agent</li><li>配置连接的 Server<ol><li><code>$ vim /etc/zabbix/zabbix_agentd.conf</code></li></ol></li><li>启动 zabbix-agent</li></ol></li></ol></li></ol><p><strong><em>踩坑指南</em></strong></p><div class="warning"><ul><li>Mariadb 代替 MySQL</li><li>关闭 SeLinux，否则可能出现：cannot set resource limit</li><li>默认使用 httpd 作为 Web 服务</li></ul></div></section><h4 id="web-使用"><a class="header-anchor" href="#web-使用"></a>Web 使用</h4><section class="reference"><p><strong><em>配置自动发现</em></strong></p><div id="flowchart-0" class="flow-chart"></div><p><strong><em>配置报警</em></strong></p><div id="flowchart-1" class="flow-chart"></div><p><strong><em>配置发送报警</em></strong></p><div id="flowchart-2" class="flow-chart"></div><p><strong><em>配置接收报警</em></strong></p><div id="flowchart-3" class="flow-chart"></div><p><strong><em>配置统计图表</em></strong></p><div id="flowchart-4" class="flow-chart"></div><p><strong><em>配置聚合图表</em></strong></p><div id="flowchart-5" class="flow-chart"></div><p><strong><em>用户管理</em></strong></p><div id="flowchart-6" class="flow-chart"></div><p><strong><em>配置聚合图表</em></strong></p><div id="flowchart-7" class="flow-chart"></div></section><h4 id="通用设置套路"><a class="header-anchor" href="#通用设置套路"></a>通用设置套路</h4><section class="reference"><div id="flowchart-8" class="flow-chart"></div></section><h4 id="web-api"><a class="header-anchor" href="#web-api"></a>Web API</h4><section class="reference"></section><h5 id="功能"><a class="header-anchor" href="#功能"></a>功能</h5><section class="reference"><ul><li>远程管理 Zabbix 配置</li><li>远程检索配置和历史数据</li></ul></section><h5 id="接入方式"><a class="header-anchor" href="#接入方式"></a>接入方式</h5><section class="reference"><ul><li><code>http://[ip]:[port]/zabbix/api_jsonrpc.php</code><ul><li>使用 JSON-RPC 实现</li><li>数据传输以 JSON 格式</li></ul></li><li>Headers<ul><li><code>Content-Type: application/json-rpc</code></li><li><code>Content-Type: application/json</code></li><li><code>Content-Type: application/jsonrequest</code></li></ul></li></ul></section><h5 id="接入步骤"><a class="header-anchor" href="#接入步骤"></a>接入步骤</h5><section class="reference"><ul><li>登录获取 token</li><li>请求头带入 Authorization: [token]</li></ul><p><strong><em>参考资料</em></strong><br><a href="https://coding.imooc.com/class/239.html#Anchor" target="_blank" rel="noopener">中小型企业通用自动化运维架构</a><br><a href="https://blog.csdn.net/u010285974/article/details/86702421" target="_blank" rel="noopener">zabbix与nagios对比</a><script src="https://cdn.bootcss.com/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.12.2/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: Configurationop2=>operation: Discovery   op3=>operation: Create Discovery Rulesop4=>operation: Create Rulesop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: Configurationop2=>operation: Create Action   op3=>operation: Create Conditionop4=>operation: Create Operationop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: Administratorop2=>operation: Media Typeop3=>operation: Emailop4=>operation: Updateop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">op1=>operation: Administratorop2=>operation: Usersop3=>operation: Adminop4=>operation: Mediaop5=>operation: Addop1(right)->op2op2(right)->op3op3(right)->op4op4(right)->op5</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">op1=>operation: Configurationop2=>operation: Hostsop3=>operation: Graphsop4=>operation: 条目选择op1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-4-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">op1=>operation: Monitoringop2=>operation: Screensop3=>operation: Addop4=>operation: Edit Screenop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-5-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script><textarea id="flowchart-6-code" style="display: none">op1=>operation: Administratorop2=>operation: Usersop3=>operation: User Groupsop1(right)->op2op2(right)->op3</textarea><textarea id="flowchart-6-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-6-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-6-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-6", options);</script><textarea id="flowchart-7-code" style="display: none">op1=>operation: Monitoringop2=>operation: Screensop3=>operation: Addop4=>operation: Edit Screenop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-7-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-7-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-7-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-7", options);</script><textarea id="flowchart-8-code" style="display: none">op1=>operation: 创建监控脚本op2=>operation: 创建 Zabbix Itemop3=>operation: 创建 Zabbix Triggerop4=>operation: 创建 Zabbix Actionop1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-8-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-8-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-8-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-8", options);</script></p></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-zabbix-？&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-zabbix-？&quot;&gt;&lt;/a&gt;什么是 Zabbix ？&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;Zabbix 是一种系统监控。网络监控
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="运维" scheme="http://www.lockey.xyz/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Zabbix" scheme="http://www.lockey.xyz/tags/Zabbix/"/>
    
      <category term="监控" scheme="http://www.lockey.xyz/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>云计算</title>
    <link href="http://www.lockey.xyz/2019/12/10/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>http://www.lockey.xyz/2019/12/10/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97/</id>
    <published>2019-12-10T07:43:55.000Z</published>
    <updated>2019-12-10T09:14:08.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><section class="reference"><p>云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。<br>现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。</p></section><h2 id="特点"><a class="header-anchor" href="#特点"></a>特点</h2><section class="reference"><ul><li>虚拟化(计算、存储、网络等)</li><li>产品服务化(IaaS、PaaS、SaaS……)</li><li>弹性伸缩</li></ul></section><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><section class="reference"><ul><li>基础设施层(IaaS)</li><li>平台层(PaaS)</li><li>软件服务层(SaaS)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/DevOps/云架构.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></section><h2 id="分类"><a class="header-anchor" href="#分类"></a>分类</h2><section class="reference"><ul><li>私有云</li><li>公有云</li><li>混合云</li></ul><p><strong><em>荤段子论</em></strong></p><blockquote><p>男人找个女友或老婆是自建<strong>私有云</strong>，单身约炮或者到娱乐场所消费是<strong>公有云</strong>服务，按需使用并可弹性扩容，已婚男人找二奶小蜜则属于<strong>混合云</strong>。</p></blockquote></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;
&lt;section class=&quot;reference&quot;&gt;
&lt;p&gt;云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.lockey.xyz/categories/DevOps/"/>
    
    
      <category term="云计算" scheme="http://www.lockey.xyz/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
